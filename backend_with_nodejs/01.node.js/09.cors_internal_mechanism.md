# Cross-Origin Resource Sharing (CORS) — Internal Mechanism and Protocol-Level Understanding

## 1. Introduction

In the previous article, CORS was configured using the `cors` middleware for practical frontend–backend integration.

This article explains:

* How CORS works at the HTTP protocol level
* What headers are involved
* How preflight requests function
* Why certain requests trigger additional checks
* How browsers enforce CORS

The objective is to move from configuration-based understanding to protocol-level clarity.

---

## 2. CORS is a Browser-Enforced Policy

CORS is implemented by web browsers as part of the **Same-Origin Policy (SOP)**.

The Same-Origin Policy restricts web pages from making requests to a different origin unless explicitly permitted.

An origin consists of:

```
Protocol + Domain + Port
```

Example:

* `http://localhost:3000`
* `http://localhost:5173`

Even if the domain is the same, a different port results in a different origin.

CORS allows controlled relaxation of this restriction through specific HTTP response headers.

---

## 3. How CORS Works at the HTTP Level

When a browser sends a cross-origin request, it includes the following header:

```
Origin: http://localhost:5173
```

This header informs the server about the requesting origin.

The server must respond with appropriate CORS headers.
The most fundamental header is:

```
Access-Control-Allow-Origin
```

If this header is:

* Present and valid → browser allows access
* Missing or mismatched → browser blocks access

Important clarification:

* The request is still processed by the server.
* The browser simply refuses to expose the response to JavaScript.

---

## 4. Core CORS Response Headers

When using the `cors` middleware, the server typically sets:

```
Access-Control-Allow-Origin
Access-Control-Allow-Methods
Access-Control-Allow-Headers
```

Each header serves a specific purpose.

---

### 4.1 Access-Control-Allow-Origin

This header specifies which origin is permitted to access the response.

Example:

```
Access-Control-Allow-Origin: http://localhost:5173
```

If the requesting origin does not match this value, the browser blocks the response.

Using:

```
Access-Control-Allow-Origin: *
```

Allows all origins, but this is not suitable for authenticated applications.

---

### 4.2 Access-Control-Allow-Methods

This header specifies which HTTP methods are allowed for cross-origin requests.

Example:

```
Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE
```

If a browser attempts to send a method not listed here, the request is blocked during the CORS validation phase.

---

### 4.3 Access-Control-Allow-Headers

This header specifies which request headers are allowed in cross-origin requests.

Example:

```
Access-Control-Allow-Headers: Content-Type, Authorization
```

If the client sends a header not included in this list, the browser blocks the request.

---

## 5. Simple vs Non-Simple Requests

Browsers classify cross-origin requests into two categories.

---

### 5.1 Simple Requests

A request is considered simple if:

* Method is GET, POST, or HEAD
* Content-Type is:

  * text/plain
  * multipart/form-data
  * application/x-www-form-urlencoded
* No custom headers are included

For simple requests:

* The browser sends the request directly.
* No preliminary check is performed.

---

### 5.2 Non-Simple Requests

A request is considered non-simple if:

* Method is PUT, PATCH, DELETE
* Content-Type is `application/json`
* Custom headers (e.g., Authorization) are included

For such requests, the browser performs a **preflight request**.

---

## 6. Preflight Request (OPTIONS Method)

Before sending a non-simple request, the browser sends an HTTP `OPTIONS` request.

This request includes headers such as:

```
Origin: http://localhost:5173
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

The purpose of the preflight request is to ask the server:

* Is this method allowed?
* Are these headers allowed?
* Is this origin allowed?

The server must respond with appropriate CORS headers.

If validation fails, the browser does not send the actual request.

---

## 7. Why JSON Triggers Preflight

Even if the method is POST, using:

```
Content-Type: application/json
```

Makes the request non-simple.

Since `application/json` is not considered a simple content type, the browser performs a preflight check.

This behavior is defined by the CORS specification and is independent of Node.js or Express.

---

## 8. Credentials and CORS

When credentials such as:

* Cookies
* Session identifiers
* Authorization tokens

Are involved, additional constraints apply.

If credentials are enabled:

```
Access-Control-Allow-Credentials: true
```

Then:

* `Access-Control-Allow-Origin` cannot be `*`
* The origin must be explicitly specified

This restriction exists to prevent unauthorized cross-site access to authenticated resources.

---

## 9. What CORS Does Not Do

CORS does not:

* Block server-to-server requests
* Prevent API misuse
* Replace authentication mechanisms
* Act as backend security

CORS only controls whether browser-based JavaScript can access a response.

Backend security must still be implemented through:

* Authentication
* Authorization
* Validation
* Rate limiting

---

## 10. Complete CORS Flow 

The complete process is as follows:

1. Browser sends request with `Origin` header.
2. If request is non-simple, browser sends an `OPTIONS` request first.
3. Server responds with appropriate CORS headers.
4. Browser validates:

   * Origin
   * Method
   * Headers
5. If validation succeeds:

   * Actual request proceeds.
6. If validation fails:

   * Browser blocks access to the response.

All CORS decisions are based entirely on HTTP header evaluation.

---

## 11. Relationship with `cors` Middleware

The `cors` middleware in Express automates:

* Setting appropriate CORS headers
* Handling preflight requests
* Ensuring consistent configuration

Understanding the underlying mechanism ensures that developers can:

* Configure CORS correctly
* Diagnose preflight failures
* Handle authenticated cross-origin requests properly
* Debug production-level integration issues

---

## 12. Conclusions

* CORS is an extension of the Same-Origin Policy.
* It operates through HTTP header negotiation.
* Browsers enforce CORS validation.
* Preflight requests ensure safety for complex interactions.
* Credentialed requests require explicit origin specification.
* Middleware abstracts complexity but does not change protocol behavior.

---

