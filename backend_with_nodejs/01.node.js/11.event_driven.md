# Event-Driven Programming in Node.js

## Understanding `EventEmitter` and How Node Reacts to Events

## 1. Why Event-Driven Programming Matters

So far, you have learned:

* HTTP servers
* REST APIs
* Express routing
* File system and streams

Now comes the **core philosophy behind Node.js**:

> **Node.js does not wait — it reacts.**

This reactive behavior is implemented using **events**.

---

## 2. What Does “Event-Driven” Mean?

An **event** is something that happens.

Examples:

* A request arrives
* A file finishes reading
* A stream receives data
* A timer completes
* A user places an order

In Node.js:

* An event is **emitted**
* One or more functions **listen**
* Those functions **execute automatically**

This pattern is called **event-driven programming**.

---

## 3. The `events` Module in Node.js

Node.js provides an inbuilt module called `events`.

This module exposes a class called **`EventEmitter`**.

```js
const EventEmitter = require("events");
```

The `EventEmitter` class allows you to:

* Create events
* Listen to events
* Trigger events

---

## 4. Creating an EventEmitter Object

```js
const EventEmitter = require("events");

const myEmitter = new EventEmitter();
```

Think of `myEmitter` as:

* An object that can **announce events**
* And allow others to **react to them**

---

## 5. Listening to an Event (`.on()`)

![Image](https://cdn-media-1.freecodecamp.org/images/sPkTz3OExo-FXteQwtFkoDVQmZeFfHE56-WJ)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20200224050909/nodejs2.png)

To listen to an event, we use `.on()`.

```js
myEmitter.on("orderPlaced", () => {
  console.log("Order received");
});
```

What this means:

* `"orderPlaced"` is the event name
* The function runs **when the event occurs**
* Nothing runs yet — we are only listening

---

## 6. Emitting an Event (`.emit()`)

```js
myEmitter.emit("orderPlaced");
```

Output:

```
Order received
```

Explanation:

* `.emit()` triggers the event
* All listeners attached to that event execute
* Execution order follows registration order

---

## 7. One Event, Multiple Listeners

![Image](https://miro.medium.com/1%2AvrqIMvX2bg8kX5MnZ0JNZA.png)

![Image](https://doimages.nyc3.cdn.digitaloceanspaces.com/006Community/W4DO_2024/Pub_Sub_NodeJS/figure2.png)

This is where EventEmitter becomes powerful.

```js
myEmitter.on("orderPlaced", () => {
  console.log("Processing payment");
});

myEmitter.on("orderPlaced", () => {
  console.log("Sending confirmation email");
});

myEmitter.on("orderPlaced", () => {
  console.log("Updating inventory");
});

myEmitter.emit("orderPlaced");
```

Output:

```
Processing payment
Sending confirmation email
Updating inventory
```

Key idea:

> One event → many independent actions

This avoids tightly coupled code.

---

## 8. Passing Data with Events

Events can also **carry data**.

```js
myEmitter.on("userRegistered", (userName) => {
  console.log("Welcome", userName);
});

myEmitter.emit("userRegistered", "Arjun");
```

Output:

```
Welcome Arjun
```

This is very common in real applications.

---

## 9. Realistic Example: File Processing Event

```js
myEmitter.on("fileSaved", (fileName) => {
  console.log("File saved:", fileName);
});

function saveFile() {
  // simulate file save
  myEmitter.emit("fileSaved", "report.txt");
}

saveFile();
```

Why this is useful:

* File logic stays separate
* Reactions can be added later
* Code remains clean

---

## 10. How Streams Use Events (Connection to Article 8)

![Image](https://images.ctfassets.net/hspc7zpa5cvq/1vZrS7rb7U7DRb5TtT8hs8/bb6285794d4141c3a572770651fcc753/cheat2.png)

![Image](https://iximiuz.com/nodejs-readable-streams-distilled/kdpv.png)

Streams internally use events like:

* `data`
* `end`
* `error`

Example you already saw:

```js
readStream.on("data", (chunk) => {
  console.log(chunk);
});
```

This works because:

* Streams are **EventEmitters**
* They emit events as data flows

---

## 11. EventEmitter vs Callback Functions

| Callback       | EventEmitter   |
| -------------- | -------------- |
| One function   | Many listeners |
| Tight coupling | Loose coupling |
| Hard to scale  | Easy to extend |

EventEmitter is preferred when:

* Multiple actions depend on one event
* Logic should remain decoupled

---

## 12. Important Rules 

* Events run **synchronously** by default
* Long operations inside listeners can block execution
* Use async code inside listeners when needed
* Event names are **case-sensitive**

Bad example:

```js
myEmitter.on("OrderPlaced", handler);
myEmitter.emit("orderPlaced"); // will NOT work
```

---

## 13. Why Node.js is Called Event-Driven

Node.js:

* Waits for events
* Reacts when they occur
* Does not block while waiting
* Coordinates everything via the event loop

HTTP requests, streams, timers, and file operations —
all rely on **events internally**.

---

## 14. Key Takeaways 

* Events represent things that happen
* `EventEmitter` powers Node’s architecture
* One event can trigger multiple actions
* Streams are event-based
* Event-driven design keeps code scalable
* This is a core Node.js concept

---
