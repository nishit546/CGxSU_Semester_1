# CORS in Node.js 

## Connecting Frontend and Backend Without Errors

When your frontend (React, Angular, etc.) tries to call your backend API, you may see this error:

```id="err1"
Access to fetch at 'http://localhost:3000' from origin 'http://localhost:5173'
has been blocked by CORS policy
```

This happens because:

* Frontend runs on one origin (e.g., port 5173)
* Backend runs on another origin (e.g., port 3000)
* Browsers block cross-origin requests by default

The solution is to configure CORS properly.

In real applications, we use the `cors` middleware.

---

# 1. Install the `cors` Package

```bash id="cmd1"
npm install cors
```

### What this does

* Installs official Express middleware for handling CORS
* Prevents you from manually writing CORS headers
* Automatically handles complex cases like preflight requests

This is the industry-standard approach.

---

# 2. Basic Setup — Allow All Origins (Development Only)

```js 
const express = require("express");
const cors = require("cors");

const app = express();

app.use(cors());   // Enables CORS globally

app.get("/users", (req, res) => {
  res.json([{ id: 1, name: "Aditya" }]);
});

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

### Core Point

`app.use(cors())`:

* Adds required CORS headers to every response
* Automatically allows all origins (`*`)
* Automatically handles preflight (OPTIONS) requests
* Works for GET, POST, PUT, PATCH, DELETE

This is perfect for:

* Local development
* Testing frontend-backend integration

But not ideal for production.

---

# 3. Restrict to a Specific Frontend (Recommended)

Instead of allowing everyone:

```js 
app.use(cors({
  origin: "http://localhost:5173"
}));
```

### Core Point

This configuration:

* Allows only requests coming from `http://localhost:5173`
* Blocks requests from other origins
* Improves security

Why this matters:

In production, you do not want unknown websites accessing your API.

---

# 4. Allow Specific HTTP Methods

```js 
app.use(cors({
  origin: "http://localhost:5173",
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE"]
}));
```

### Core Point

This controls which HTTP methods are allowed in cross-origin requests.

If your frontend sends a `PUT` request but it is not listed here:

* The browser blocks it
* The request never reaches your route handler

This adds another layer of control.

---

# 5. Handling JSON Requests

Frontend example:

```js 
fetch("http://localhost:3000/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({ name: "Aditya" })
});
```

Backend:

```js 
app.use(cors());
app.use(express.json());
```

### Core Point

* `cors()` allows cross-origin access
* `express.json()` parses JSON request bodies
* You do NOT need extra CORS configuration for JSON
* The `cors` package automatically handles the required preflight logic

---

# 6. Working with Cookies / Sessions

If your backend uses:

* Session cookies
* Login-based authentication

You must configure credentials.

Backend:

```js 
app.use(cors({
  origin: "http://localhost:5173",
  credentials: true
}));
```

Frontend:

```js 
fetch("http://localhost:3000/profile", {
  credentials: "include"
});
```

### Core Point

`credentials: true` allows:

* Cookies
* Session IDs
* Authentication headers

Important rule:

When using `credentials: true`, you CANNOT use:

```js
origin: "*"
```

Because browsers do not allow wildcard origin with credentials.

This is a very common production mistake.

---

# 7. Middleware Order Matters

Correct structure:

```js 
app.use(cors());          // 1 CORS first
app.use(express.json());  // 2 Body parser
app.use("/users", routes); // 3 Routes
```

### Core Point

Express executes middleware in order.

If you add CORS after routes:

* Headers may not be applied correctly
* Browser will still block requests

Always configure CORS at the top.

---

Perfect — we’ll keep it simple and practical, without dynamic validation logic.

You can directly add this small section before your **Production-Ready Example**.

---

# 8. Allowing Multiple Frontend Origins

In real projects, your backend may need to allow more than one frontend, such as:

* Local development (`http://localhost:5173`)
* Production frontend (`https://codinggita.com`)

You can allow multiple origins like this:

```js
app.use(cors({
  origin: [
    "http://localhost:5173",
    "https://codinggita.com"
  ]
}));
```

### Core Point

* The `origin` option accepts an array.
* Only the origins listed in the array are allowed.
* If a request comes from any other origin, the browser blocks it.
* This is useful when you have separate development and production frontends.

This keeps configuration clear and controlled without adding unnecessary complexity.

---

# 9. When You Do NOT Need CORS

You do not need CORS for:

* Same-origin frontend and backend
* Postman requests
* Server-to-server communication
* Mobile apps calling APIs directly

### Core Point

CORS is enforced by browsers only.

It is not a backend security feature.

---

# 10. Production-Ready Example

```js 
const express = require("express");
const cors = require("cors");

const app = express();

app.use(cors({
  origin: "http://localhost:5173",
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE"],
  credentials: true
}));

app.use(express.json());

app.get("/users", (req, res) => {
  res.status(200).json([
    { id: 1, name: "Aditya" },
    { id: 2, name: "Priyesha" }
  ]);
});

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

### Core Points in This Setup

* Origin is restricted
* Methods are explicitly defined
* Credentials are supported
* Middleware order is correct
* JSON parsing is enabled
* Ready for frontend integration

This is how most real-world Node.js apps configure CORS.

---

# Summary

* Browser blocks cross-origin requests by default
* `cors` middleware adds permission headers automatically
* Restrict origin in real projects
* Use `credentials: true` when working with authentication
* Always configure CORS before routes

---

