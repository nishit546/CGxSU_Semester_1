# Creating a Server Using the HTTP Module

## Understanding How Backend Servers Actually Work

## 1. What Does “Creating a Server” Mean?

At its core, a **server** is a program that:

* Listens on a specific port
* Waits for incoming requests
* Processes those requests
* Sends back responses

In Node.js, this behavior is provided by the **`http` core module**.

Before using any framework, it is important to understand this raw mechanism.

---

## 2. Why Start with the HTTP Module?

Frameworks like Express are built **on top of** the `http` module.

By starting here, you learn:

* How requests actually arrive
* How responses are sent back
* What Express is abstracting for you
* Why Node.js can handle many users concurrently

This prevents treating backend code as a black box.

---

## 3. Creating a Basic HTTP Server

A minimal HTTP server in Node.js looks like this:

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Server is running");
});

server.listen(3000, () => {
  console.log("Server started on port 3000");
});
```

### What is happening here?

* `http.createServer()` creates a server instance
* The callback runs **every time a request is received**
* `req` represents the incoming request
* `res` represents the outgoing response
* `listen()` binds the server to a port

---

## 4. Request–Response Lifecycle

Each request goes through the following steps:

1. Client sends a request
2. Node.js receives it on the server
3. Callback function is executed
4. Response is constructed
5. Response is sent back to the client

This entire flow is **event-driven**, not blocking.

---

## 5. Understanding the `req` Object

The `req` (request) object contains details about the incoming request.

Commonly used properties:

* `req.method` → HTTP method (GET, POST, etc.)
* `req.url` → Requested URL
* `req.headers` → Request headers

Example:

```js
const server = http.createServer((req, res) => {
  console.log(req.method);
  console.log(req.url);

  res.end("Check the console");
});
```

This information allows the server to decide **how to respond**.

---

## 6. Understanding the `res` Object

The `res` (response) object is used to send data back to the client.

Common operations:

* Set status codes
* Set headers
* Send response body

Example:

```js
res.writeHead(200, { "Content-Type": "application/json" });
res.end(JSON.stringify({ message: "Success" }));
```

Important rule:

> Every request must end with `res.end()`

If not, the client will keep waiting.

---

## 7. Handling Routes Manually

Without a framework, routing is handled using conditions.

Example:

```js
const server = http.createServer((req, res) => {
  if (req.method === "GET" && req.url === "/users") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ users: [] }));
  } else {
    res.writeHead(404);
    res.end("Route not found");
  }
});
```

This works, but becomes difficult to manage as the application grows.

This is one of the main reasons frameworks exist.

---

## 8. How Node.js Handles Multiple Requests

![Image](https://i.sstatic.net/awRTq.png)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220208175332/resizedimagePromo2-660x371.jpeg)

Even though JavaScript runs on a **single thread**, Node.js can handle many requests because:

* I/O operations are non-blocking
* Heavy tasks are offloaded to the **libuv worker pool**
* The event loop keeps the server responsive

As long as you avoid blocking code, one Node.js process can handle thousands of concurrent connections.

---

## 9. Why Blocking Code is Dangerous in Servers

If a request handler contains blocking code:

* The event loop stops
* All incoming requests wait
* Server appears frozen

Example of what **not** to do:

```js
while (true) {
  // blocking loop
}
```

This blocks the entire server.

This is why async programming is mandatory in Node.js backend development.

---

## 10. Key Takeaways

* The `http` module is the foundation of backend servers
* Every request triggers a callback
* Requests and responses are event-driven
* Node.js handles concurrency using non-blocking I/O
* Blocking the main thread freezes the server
* Frameworks exist to simplify routing and structure

---
