# **Reading Documents in MongoDB – Advanced & Real-World Queries**

Up to now, you’ve learned how to:

* read documents
* apply comparison and logical operators
* query arrays
* think about schema consistency

Now we move into **real-world backend querying**, where:

* conditions are combined
* logic is inverted
* expressions depend on fields
* performance matters

This article covers **advanced operators that appear in real production systems**.

---

## **Prerequisite: Insert Practice Data**

Insert the following documents **once** to run all queries safely.

```javascript
use codinggita

db.jobs.insertMany([
  {
    role: "Backend Developer",
    experience: 3,
    location: "Bangalore",
    salary: 1200000,
    company: "Flipkart"
  },
  {
    role: "Software Engineer",
    experience: 1,
    location: "Remote",
    salary: 800000,
    company: "Startup"
  },
  {
    role: "Senior Backend Engineer",
    experience: 6,
    location: "Hyderabad",
    salary: 2500000,
    company: "Amazon"
  },
  {
    role: "Full Stack Developer",
    experience: 4,
    location: "Bangalore",
    salary: 1600000,
    company: "Swiggy"
  }
]);
```

---

## **1. Negation Operators – `$not` and `$nor`**

Sometimes backend logic is about **excluding data**, not selecting it.

---

### **Negation Operators – Overview**

| Operator | Meaning                      | Logical Mapping |
| -------- | ---------------------------- | --------------- |
| `$not`   | Negates a condition          | NOT             |
| `$nor`   | None of the conditions match | NOT (A OR B)    |

---

## **2. `$not` – Negating a Condition**

`$not` is used **inside a field condition**.

---

### **Example: Jobs NOT requiring more than 2 years experience**

```javascript
db.jobs.find({
  experience: { $not: { $gt: 2 } }
})
```

Meaning:

* include experience ≤ 2
* exclude experience > 2

---

### **Important Note**

❌ This is **wrong usage**:

```javascript
{ $not: { experience: { $gt: 2 } } }
```

`$not` **must be applied at field level**, not query root.

---

## **3. `$nor` – Negation Across Multiple Conditions**

`$nor` excludes documents that match **any condition** inside it.

---

### **Example: Exclude Amazon and Bangalore Jobs**

```javascript
db.jobs.find({
  $nor: [
    { company: "Amazon" },
    { location: "Bangalore" }
  ]
})
```

This returns:

* jobs not from Amazon
* AND not in Bangalore

---

### **Logical Meaning**

```
NOT (company = Amazon OR location = Bangalore)
```

---

## **4. `$regex` – Pattern Matching (Carefully)**

MongoDB supports regular expressions for string fields.

---

### **Regex Operator Mapping**

| Pattern | Meaning        |
| ------- | -------------- |
| `^`     | Starts with    |
| `$`     | Ends with      |
| `.*`    | Any characters |

---

### **Example: Roles Starting with “Senior”**

```javascript
db.jobs.find({
  role: { $regex: "^Senior" }
})
```

---

### **Example: Roles Ending with “Developer”**

```javascript
db.jobs.find({
  role: { $regex: "Developer$" }
})
```

---

### **Case-Insensitive Regex**

```javascript
db.jobs.find({
  role: { $regex: "backend", $options: "i" }
})
```

---

### **⚠ Performance Warning (Very Important)**

* Regex **does not use indexes** unless it starts with `^`
* Regex scans the collection
* Avoid regex in high-traffic APIs

Use regex **only when absolutely necessary**.

---

## **5. `$expr` – Comparing Fields Inside a Document**

Normally, MongoDB queries compare a **field with a fixed value**.

Example:

```javascript
db.jobs.find({ experience: { $gt: 3 } })
```

This compares:

```
experience → number
```

But in real-world backend logic, you often need to compare **one field with another field inside the same document**.
This is where `$expr` is required.

---

### **When `$expr` Is Needed**

Use `$expr` when:

* a condition depends on **two fields**
* business logic cannot be expressed using fixed values
* calculations are involved

Without `$expr`, **field-to-field comparison is not possible**.

---

### **Field-to-Field Comparison Concept**

Normal query:

```
field → value
```

With `$expr`:

```
field → field (or expression)
```

---

### **Example 1: Salary Greater Than (Experience × 5 Lakh)**

```javascript
db.jobs.find({
  $expr: {
    $gt: ["$salary", { $multiply: ["$experience", 500000] }]
  }
})
```

**What this means in plain terms:**

* multiply `experience` by 5,00,000
* compare it with `salary`
* return documents where salary is higher

This kind of logic is common in **pay-band validation systems**.

---

### **Example 2: Experience Greater Than Salary Bracket Rule**

Assume a rule:

> A job is valid only if experience is less than salary / 10,00,000

```javascript
db.jobs.find({
  $expr: {
    $lt: ["$experience", { $divide: ["$salary", 1000000] }]
  }
})
```

Here:

* salary is divided by 10 lakh
* experience is compared against that value

---

### **Common `$expr` Operators**

| Operator    | Meaning        |
| ----------- | -------------- |
| `$gt`       | Greater than   |
| `$lt`       | Less than      |
| `$eq`       | Equal          |
| `$add`      | Addition       |
| `$multiply` | Multiplication |
| `$divide`   | Division       |

---

### **Important Note**

* `$expr` runs **per document**
* It is powerful but **slower than normal queries**
* Use it only when fixed-value filters are not enough

---

## **6. Operator Composition (Real Queries)**

Real queries combine **multiple operators**.

---

### **Example: Mid-Level Bangalore Backend Jobs**

```javascript
db.jobs.find({
  role: { $regex: "Backend", $options: "i" },
  experience: { $gte: 3, $lte: 5 },
  location: "Bangalore",
  salary: { $gt: 1000000 }
})
```

This query uses:

* regex
* range filter
* implicit AND
* numeric comparison

This is **real backend filtering**.

---

## **7. Performance Awareness (Critical for Developers)**

MongoDB will:

* execute your query
* not warn you
* even if it’s inefficient

---

### **Common Performance Pitfalls**

| Mistake             | Impact         |
| ------------------- | -------------- |
| Regex without `^`   | Full scan      |
| `$expr` everywhere  | Slower queries |
| Inconsistent schema | Wrong results  |
| Too many conditions | Index misuse   |

---

### **Rule of Thumb**

* Prefer **exact matches**
* Use regex sparingly
* Think about **query frequency**
* Design schema for queries, not vice versa

---

## **Key Takeaways**

After this article, you should be able to:

* use `$not` and `$nor` correctly
* write safe regex queries
* understand when `$expr` is required
* compose real-world MongoDB queries
* think about query performance

---

