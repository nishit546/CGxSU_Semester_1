# **Projections & Pagination (Reading Large Datasets Correctly)**

So far, our read queries worked because:

* we had very few documents
* returning full documents did not hurt

That changes **immediately** when a collection grows.

Now assume this:

* You imported `restaurant.json`
* The collection contains **~2,500 restaurant documents**
* Each document looks like this:

```json
{
  "URL": "http://www.just-eat.co.uk/restaurants-cn-chinese-cardiff/menu",
  "address": "228 City Road",
  "address line 2": "Cardiff",
  "name": ".CN Chinese",
  "outcode": "CF24",
  "postcode": "3JH",
  "rating": 5,
  "type_of_food": "Chinese"
}
```

Reading data **incorrectly** at this scale leads to:

* slow queries
* large payloads
* wasted memory
* unusable backend responses

This article explains **how to read large datasets responsibly**.

---

## **1. The Default Problem: MongoDB Returns Everything**

Try this:

```javascript
db.restaurants.find()
```

What happens?

* MongoDB scans the collection
* returns **every field**
* returns **every document**
* sends **huge payloads** to the client

With 2.5k records, this is already inefficient.
With 25k or 2.5 million ‚Äî this becomes dangerous.

üëâ MongoDB does **exactly what you ask**, not what you *meant*.

---

## **2. Projections ‚Äì Reading Only What You Need**

A **projection** tells MongoDB:

> ‚ÄúReturn only specific fields. Ignore the rest.‚Äù

---

### **Basic Projection Syntax**

```javascript
db.collection.find(query, projection)
```

Where:

* `1` ‚Üí include field
* `0` ‚Üí exclude field

---

### **Example: Show Only Restaurant Names**

```javascript
db.restaurants.find(
  {},
  { name: 1 }
)
```

Returned per document:

```json
{
  "_id": ObjectId("..."),
  "name": "@ Thai"
}
```

MongoDB still includes `_id` by default.

---

### **Removing `_id` (Very Common)**

```javascript
db.restaurants.find(
  {},
  { name: 1, _id: 0 }
)
```

Now MongoDB returns **only what you asked for**.

This is how **real backend responses** should look.

---

### **Why Projections Matter (Real Reason)**

Without projections:

* unnecessary fields are transferred
* memory usage increases
* response time increases
* frontend parses useless data

With projections:

* payload size drops massively
* queries become predictable
* responses are cleaner

---

## **3. Include vs Exclude Projections**

### **Include Specific Fields**

```javascript
db.restaurants.find(
  {},
  { name: 1, rating: 1, type_of_food: 1, _id: 0 }
)
```

Good for:

* listing pages
* search results
* filters

---

### **Exclude Fields Instead**

```javascript
db.restaurants.find(
  {},
  { URL: 0 }
)
```

This returns everything **except the URL**.

‚ö† Rule:

> You cannot mix include and exclude (except `_id`)

---

## **4. Sorting ‚Äì Ordering Large Result Sets**

When you have thousands of documents, **order matters**.

---

### **Sort by Rating (High to Low)**

```javascript
db.restaurants.find().sort({ rating: -1 })
```

MongoDB sorts documents **before returning them**.

---

### **Sort by Food Type, Then Rating**

```javascript
db.restaurants.find().sort({
  type_of_food: 1,
  rating: -1
})
```

Meaning:

* group by food type
* highest rated first within each group

Sorting decides:

* what users see first
* what looks ‚Äúbest‚Äù
* how search feels

---

## **5. Pagination ‚Äì Controlling How Much Data Is Returned**

Returning thousands of records at once is a **bad idea**.

Pagination exists to:

* protect the database
* protect the backend
* protect the frontend

---

### **Limit ‚Äì How Many Documents**

```javascript
db.restaurants.find().limit(10)
```

Returns only **10 restaurants**.

---

### **Skip ‚Äì Where to Start From**

```javascript
db.restaurants.find().skip(10).limit(10)
```

This returns:

* documents 11‚Äì20

This is **page 2**.

---

### **Page Formula (Important)**

```text
skip = (pageNumber - 1) √ó pageSize
```

Example: Page 5, size 20

```javascript
db.restaurants.find().skip(80).limit(20)
```

---

## **6. Realistic Query Using All Three**

Now let‚Äôs read data **the correct way**.

---

### **Example: Restaurant Listing Page**

```javascript
db.restaurants.find(
  { type_of_food: "Thai" },
  { name: 1, rating: 1, outcode: 1, _id: 0 }
)
.sort({ rating: -1 })
.skip(0)
.limit(10)
```

This query:

* filters Thai restaurants
* returns only required fields
* sorts by rating
* paginates results

This is **production-quality MongoDB reading**.

---

## **7. Why This Article Matters**

At small scale, bad reads go unnoticed.
At scale, they:

* slow systems
* increase costs
* cause outages

MongoDB gives you **full control**, but also **full responsibility**.

---

## **Key Takeaways**

After this article, you should understand:

* why returning full documents is dangerous
* how projections reduce payload size
* how sorting changes data meaning
* why pagination is mandatory at scale
* how to read large collections safely

---