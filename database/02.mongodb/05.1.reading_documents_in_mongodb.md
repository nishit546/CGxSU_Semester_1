# **Reading Documents in MongoDB (Basic Queries)**

Before you can update or delete data, you must be able to **read it correctly**.

In real backend systems:

* every API starts with a read
* validation depends on reads
* updates and deletes are always based on read conditions

So if inserts are about **writing data**, reads are about **understanding what you wrote**.

This article focuses only on **basic read operations** — no operators, no complexity yet.

---

## **1. What Does “Read” Mean in MongoDB?**

In MongoDB, **Read** means:

> Fetching documents from a collection based on some condition

MongoDB does not “select rows”.
It **finds documents**.

Reading data allows you to:

* verify inserts
* fetch user data
* power APIs
* prepare data for updates or deletes

---

# **Prerequisite: Insert One Document for Practice**

Before running any `find()` or `findOne()` commands, make sure **at least one document exists** in the collection.

If you are starting fresh, follow these steps **once**.

---

### **Step 1: Select the Database**

```javascript
use codinggita
```

---

### **Step 2: Insert One Student Document**

```javascript
db.students.insertOne({
  name: "Arjun",
  rollNumber: "CG101",
  department: "CSE",
  year: 3,
  coursesEnrolled: ["DBMS", "Data Structures", "Algorithms"],
  age: 22,
  registrationDate: new Date()
});
```

---

### **Why This Document Is Enough**

This single document allows you to practice:

* `find()`
* `findOne()`
* filtering by string (`department`)
* filtering by number (`year`)
* matching array values (`coursesEnrolled`)

All examples in this article will work using this data.

---

## **2. The `find()` Method (Most Important)**

The most commonly used read method in MongoDB is:

```javascript
db.collectionName.find()
```

This command:

* returns **all documents** in the collection
* returns results in **cursor format**
* does not modify data

---

### **Example: Read All Students**

```javascript
db.students.find()
```

This will return **every document** inside the `students` collection.

At this stage:

* don’t worry about formatting
* don’t worry about performance
* just understand **what comes back**

---

## **3. Reading with a Filter (Exact Match)**

Most real reads use a **condition**.

### **Syntax**

```javascript
db.collectionName.find({ field: value })
```

---

### **Example: Find Students from CSE Department**

```javascript
db.students.find({ department: "CSE" })
```

What this does:

* MongoDB scans the collection
* returns documents where `department` exactly matches `"CSE"`

Important:

* MongoDB matching is **case-sensitive**
* `"cse"` ≠ `"CSE"`

---

## **4. Using `findOne()`**

Sometimes you expect **only one document**.

MongoDB provides:

```javascript
db.collectionName.findOne()
```

---

### **Example: Find One Student**

```javascript
db.students.findOne({ rollNumber: "12345" })
```

Key differences from `find()`:

| `find()`                   | `findOne()`               |
| -------------------------- | ------------------------- |
| Returns multiple documents | Returns only one document |
| Cursor                     | Single document           |
| Used for lists             | Used for detail views     |

Use `findOne()` when:

* fetching profile data
* fetching a single record
* uniqueness is expected

---

## **5. Understanding Query Matching**

MongoDB uses **exact field matching** by default.

Example:

```javascript
db.students.find({ year: 3 })
```

This will **not** match:

```json
"year": "3"
```

Why this matters:

* MongoDB is **type-sensitive**
* Numbers ≠ Strings
* Bad inserts cause bad reads

This reinforces why correct inserts matter.

---

## **6. Reading Nested and Array Fields (Basic)**

MongoDB can match array values naturally.

### **Example: Find Students Enrolled in DBMS**

```javascript
db.students.find({ coursesEnrolled: "DBMS" })
```

MongoDB understands:

* `coursesEnrolled` is an array
* `"DBMS"` exists inside the array

No special syntax needed at this level.

---

## **7. Reading Only to Verify Data**

At this stage, reads are mostly used to:

* confirm inserts worked
* inspect document structure
* understand stored data

Avoid:

* complex conditions
* chaining commands
* optimizations (for now)

---

## **8. Common Beginner Mistakes in Reads**

### ❌ Expecting partial matches

```javascript
db.students.find({ name: "Ar" })
```

MongoDB will **not** do partial matching by default.

---

### ❌ Assuming MongoDB ignores data types

```javascript
db.students.find({ year: "2" })
```

If `year` is stored as a number, this returns **nothing**.

---

### ❌ Forgetting current database

Running `find()` in the wrong database returns nothing — even if data exists elsewhere.

Always ensure:

```javascript
db
```

returns the correct database.

---

## **Key Takeaways**

After this article, you should be able to:

* Read all documents from a collection
* Read documents using exact match filters
* Understand the difference between `find()` and `findOne()`
* Recognize why correct data types matter
* Use reads to verify inserts safely

---
