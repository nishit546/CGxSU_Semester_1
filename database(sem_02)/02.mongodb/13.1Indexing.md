# MongoDB Query Optimization and Indexing

## Practical and In-Depth Understanding of Indexes (Professional Notes)

### 1. Introduction to Query Optimization

As applications scale, database performance becomes a critical factor in system reliability and user experience. Poorly optimized database queries are one of the most common causes of latency, excessive resource consumption, and system degradation in production environments.

In MongoDB, indexing is the primary mechanism used to optimize query execution. Proper index design enables MongoDB to retrieve data efficiently while minimizing CPU usage, memory consumption, and disk I/O.

This chapter provides a deep technical understanding of MongoDB indexing, query execution behavior, index types, performance trade-offs, and best practices required for building scalable production systems.

### 2. What Is Indexing in MongoDB?

An index is a specialized data structure that allows MongoDB to efficiently locate documents without scanning the entire collection.

#### Without an Index

MongoDB must:

- Perform a full collection scan
- Examine every document
- Evaluate the query condition on each document
- Filter and return matching results

This operation is known as a Collection Scan (COLLSCAN) and becomes increasingly expensive as data volume grows.

#### With an Index

MongoDB can:

- Directly locate matching index keys
- Fetch only relevant documents
- Avoid unnecessary document inspection

This optimized operation is called an Index Scan (IXSCAN).

### 3. Internal Working of Indexes

When an index is created, MongoDB builds a separate data structure, typically a B-Tree, that stores:

- Indexed field values in sorted order
- References (pointers) to the original documents

#### Benefits of B-Tree Indexes

- Logarithmic-time lookups
- Efficient range queries
- Optimized sorting operations
- Reduced disk and memory usage

Indexes do not store entire documents; they store only indexed fields and document references.

### 4. Creating Indexes in MongoDB

MongoDB uses the createIndex() method to define indexes.

#### 4.1 Single Field Index

```javascript
db.students.createIndex({ rollNumber: 1 })
```

**Behavior:**

- Values are stored in ascending order
- Optimizes equality queries and sorting on rollNumber

**Use Case:**

- Queries filtering by a unique or frequently accessed field

#### 4.2 Compound Index

```javascript
db.students.createIndex({ year: 1, department: 1 })
```

**Internal Ordering:**

- Documents are grouped by year
- Within each year, they are sorted by department

**Prefix Rule:**

This index supports:

- Queries on year
- Queries on year and department
- ❌ Not queries only on department

Correct index field ordering must match real query patterns.

### 5. Types of Indexes in MongoDB

#### 5.1 Multikey Index (Array Fields)

When an indexed field contains an array, MongoDB automatically creates a multikey index.

```javascript
db.students.createIndex({ skills: 1 })
```

**Behavior:**

- Each array element is indexed independently

**Use Cases:**

- Tags
- Skills
- Categories
- Feature lists

Multikey indexes are essential for efficient querying of array data.

#### 5.2 Text Index (Full-Text Search)

```javascript
db.students.createIndex({ coursesEnrolled: "text" })

db.students.find({ $text: { $search: "Data Structures" } })
```

**Characteristics:**

- Tokenizes text fields
- Supports keyword search
- Can rank results by relevance
- Only one text index allowed per collection

**Use Cases:**

- Search functionality
- Knowledge bases
- Course or blog platforms

#### 5.3 Hashed Index

```javascript
db.students.createIndex({ rollNumber: "hashed" })
```

**Purpose:**

- Uniform data distribution
- Primarily used in sharded clusters

**Limitations:**

- Does not support range queries
- Does not support sorting

Hashed indexes are optimized for equality lookups and shard key distribution.

#### 5.4 Geospatial Index

```javascript
db.students.createIndex({ location: "2dsphere" })
```

**Capabilities:**

- Distance-based queries
- Proximity searches
- Geographic filtering

**Use Cases:**

- Location-aware applications
- Mapping systems
- Nearby search features

### 6. Query Execution Without Index (COLLSCAN)

```javascript
db.jobs.find({ location: "Bangalore" })
```

**Execution Steps:**

- MongoDB scans all documents
- Applies filter condition to each document
- Returns matching results

**Verification:**

```javascript
db.jobs.find({ location: "Bangalore" }).explain("executionStats")
```

**Indicator:**

```json
"stage": "COLLSCAN"
```

**Risks of COLLSCAN**

- Execution time increases with data size
- High CPU and memory consumption
- Poor scalability
- Unsuitable for production systems

### 7. Query Execution With Index (IXSCAN)

```javascript
db.jobs.createIndex({ location: 1 })

db.jobs.find({ location: "Bangalore" })
```

**Execution Steps:**

- MongoDB searches the index
- Locates matching index entries
- Fetches only relevant documents

**Verification:**

```javascript
db.jobs.find({ location: "Bangalore" }).explain("executionStats")
```

**Indicator:**

```json
"stage": "IXSCAN"
```

### 8. Sorting and Index Interaction

#### Sorting Without Index

```javascript
db.jobs.find().sort({ salaryLPA: -1 })
```

MongoDB must:

- Load all documents
- Sort in memory
- Potentially spill to disk

#### Optimized Sorting

```javascript
db.jobs.createIndex({ salaryLPA: -1 })
```

Sorting is performed directly using the index.

#### Filtering + Sorting

```javascript
db.jobs.createIndex({ location: 1, salaryLPA: -1 })
```

This compound index efficiently supports both filtering and sorting.

### 9. Forcing Index Usage with hint()

```javascript
db.students.find({ rollNumber: "12345" }).hint({ rollNumber: 1 })
```

**Usage:**

- Debugging
- Performance testing
- Query optimization analysis

Should be avoided in routine production queries.

### 10. Query Analysis Using explain()

```javascript
db.students.find({ year: 2 }).explain("executionStats")
```

**Key Metrics:**

- Query execution plan
- Index usage
- Documents examined
- Execution time

A COLLSCAN indicates a potential optimization opportunity.

### 11. Index Trade-Offs and Write Performance

Indexes improve read performance but introduce overhead.

Every write operation must:

- Modify the document
- Update all associated indexes

Excessive indexing can:

- Slow inserts and updates
- Increase disk usage
- Consume additional memory

Index design must balance read performance and write cost.

### 12. Best Practices for Index Design

| Best Practice | Reason |
| :--- | :--- |
| Design based on real queries | Avoid unnecessary indexes |
| Use compound indexes | Serve multiple query patterns |
| Follow index order carefully | Respect the prefix rule |
| Monitor with explain() | Validate effectiveness |
| Remove unused indexes | Improve write performance |
| Balance reads and writes | Prevent system overload |

### 13. Final Summary

Indexing is the foundation of MongoDB performance optimization. Effective index design requires understanding:

- Query patterns
- Data growth
- Read/write workload
- Internal execution behavior

Indexing is not a syntactic feature — it is a core database engineering discipline essential for building scalable, production-grade systems.
