# MongoDB Query Optimization and Indexing



### 1. Introduction to Query Optimization

As applications scale, database performance becomes a critical factor in system reliability and user experience. Poorly optimized database queries are one of the most common causes of latency, excessive resource consumption, and system degradation in production environments.

In MongoDB, indexing is the primary mechanism used to optimize query execution. Proper index design enables MongoDB to retrieve data efficiently while minimizing CPU usage, memory consumption, and disk I/O.

This chapter provides a deep technical understanding of MongoDB indexing, query execution behavior, index types, performance trade-offs, and best practices required for building scalable production systems.

### 2. What Is Indexing in MongoDB?

An index is a special data structure in MongoDB that helps the database find documents quickly.
Instead of checking every document one by one in a collection, MongoDB uses the index to directly locate the required data.
This makes queries faster, reduces the amount of work MongoDB has to do, and improves overall performance, especially when the collection contains a large number of documents.

#### Without an Index

MongoDB must:

- Perform a full collection scan
- Examine every document
- Evaluate the query condition on each document
- Filter and return matching results

This operation is known as a Collection Scan (COLLSCAN) and becomes increasingly expensive as data volume grows.

#### With an Index

MongoDB can:

- Directly locate matching index keys
- Fetch only relevant documents
- Avoid unnecessary document inspection

This optimized operation is called an Index Scan (IXSCAN).

### 3. Internal Working of Indexes

When an index is created, MongoDB builds a separate data structure, typically a B-Tree, that stores:

- Indexed field values in sorted order
- References (pointers) to the original documents

#### Benefits of B-Tree Indexes

- Logarithmic-time lookups
- Efficient range queries
- Optimized sorting operations
- Reduced disk and memory usage

Indexes do not store entire documents; they store only indexed fields and document references.

### 4. Creating Indexes in MongoDB

MongoDB uses the createIndex() method to define indexes.

#### 4.1 Single Field Index

A single field index is an index created on one field of a document.
It helps MongoDB quickly find documents based on the value of that single field.
This type of index is simple to use and is commonly applied when queries frequently filter or sort data using one specific field.

```javascript
db.students.createIndex({ rollNumber: 1 })
```

**Behavior:**

- Values are stored in ascending order
- Optimizes equality queries and sorting on rollNumber

**Use Case:**

- Queries filtering by a unique or frequently accessed field

#### 4.2 Compound Index

A compound index is an index created on two or more fields in a specific order.
It improves query performance when MongoDB needs to filter or sort documents using multiple fields together.
The order of fields in a compound index is important because it determines which queries can effectively use the index.

```javascript
db.students.createIndex({ year: 1, department: 1 })
```

**Internal Ordering:**

- Documents are grouped by year
- Within each year, they are sorted by department

**Prefix Rule:**

This index supports:

- Queries on year
- Queries on year and department
- ❌ Not queries only on department

Correct index field ordering must match real query patterns.

### 5. Types of Indexes in MongoDB

#### 5.1 Multikey Index (Array Fields)

When an indexed field contains an array, MongoDB automatically creates a multikey index.
This means MongoDB creates index entries for each value inside the array.
As a result, queries that search for specific values within an array become much faster, without scanning every document in the collection.


```javascript
db.students.createIndex({ skills: 1 })
```

**Behavior:**

- Each array element is indexed independently

**Use Cases:**

- Tags
- Skills
- Categories
- Feature lists

Multikey indexes are essential for efficient querying of array data.

#### 5.2 Text Index (Full-Text Search)

A text index is used to search text content inside string fields.
It allows MongoDB to perform full-text searches such as finding words or phrases within documents.
Text indexes support features like keyword searching and relevance scoring, making them useful for search functionality similar to search engines.

```javascript
db.students.createIndex({ coursesEnrolled: "text" })

db.students.find({ $text: { $search: "Data Structures" } })
```

**Characteristics:**

- Tokenizes text fields
- Supports keyword search
- Can rank results by relevance
- Only one text index allowed per collection

**Use Cases:**

- Search functionality
- Knowledge bases
- Course or blog platforms

#### 5.3 Hashed Index

A hashed index stores a hash value of the indexed field instead of the actual value.
This type of index is mainly used for equality-based queries and is very useful in sharded collections.
Hashed indexes help distribute data evenly across shards but are not suitable for range queries.

```javascript
db.students.createIndex({ rollNumber: "hashed" })
```

**Purpose:**

- Uniform data distribution
- Primarily used in sharded clusters

**Limitations:**

- Does not support range queries
- Does not support sorting

Hashed indexes are optimized for equality lookups and shard key distribution.

#### 5.4 Geospatial Index

A geospatial index is used to store and query location-based data such as coordinates.
It allows MongoDB to efficiently find documents based on distance, area, or location relationships.
Geospatial indexes are commonly used in applications like maps, delivery tracking, and location-based services.


```javascript
db.students.createIndex({ location: "2dsphere" })
```

**Capabilities:**

- Distance-based queries
- Proximity searches
- Geographic filtering

**Use Cases:**

- Location-aware applications
- Mapping systems
- Nearby search features

### 6. Query Execution Without Index (COLLSCAN)

When a query runs on a field without an index, MongoDB performs a COLLSCAN.
In COLLSCAN, MongoDB checks every document in the collection one by one to find matching data.
This is slow and inefficient for large datasets, so it should be avoided in production by using proper indexes.

```javascript
db.jobs.find({ location: "Bangalore" })
```

**Execution Steps:**

- MongoDB scans all documents
- Applies filter condition to each document
- Returns matching results

**Verification:**

```javascript
db.jobs.find({ location: "Bangalore" }).explain("executionStats")
```

**Indicator:**

```json
"stage": "COLLSCAN"
```

**Risks of COLLSCAN**

- Execution time increases with data size
- High CPU and memory consumption
- Poor scalability
- Unsuitable for production systems

### 7. Query Execution With Index (IXSCAN)

When a query uses an indexed field, MongoDB performs an IXSCAN.
In IXSCAN, MongoDB directly uses the index to locate matching documents instead of scanning the entire collection.
This makes query execution faster and more efficient, especially for large datasets.

```javascript
db.jobs.createIndex({ location: 1 })

db.jobs.find({ location: "Bangalore" })
```

**Execution Steps:**

- MongoDB searches the index
- Locates matching index entries
- Fetches only relevant documents

**Verification:**

```javascript
db.jobs.find({ location: "Bangalore" }).explain("executionStats")
```

**Indicator:**

```json
"stage": "IXSCAN"
```

### 7.1 COLLSCAN vs IXSCAN

| Feature                | COLLSCAN                               | IXSCAN                               |
|------------------------|----------------------------------------|--------------------------------------|
| Meaning                | Collection Scan                        | Index Scan                           |
| Index Required         | No                                     | Yes                                  |
| How It Works           | Checks every document one by one       | Uses index to find matching documents |
| Performance            | Slow for large datasets                | Fast and efficient                   |
| Resource Usage         | High CPU and memory usage              | Low CPU and memory usage             |
| Scalability            | Poor                                   | Good                                 |
| Suitable For           | Small datasets, testing, development   | Large datasets, production systems   |
| Recommended in Prod    | No                                     | Yes                                  |




### 8. Sorting and Index Interaction

#### Sorting Without Index

```javascript
db.jobs.find().sort({ salaryLPA: -1 })
```

MongoDB must:

- Load all documents
- Sort in memory
- Potentially spill to disk

#### Optimized Sorting

```javascript
db.jobs.createIndex({ salaryLPA: -1 })
```

Sorting is performed directly using the index.

#### Filtering + Sorting

```javascript
db.jobs.createIndex({ location: 1, salaryLPA: -1 })
```

This compound index efficiently supports both filtering and sorting.

### 9. Forcing Index Usage with hint()

```javascript
db.students.find({ rollNumber: "12345" }).hint({ rollNumber: 1 })
```

**Usage:**

- Debugging
- Performance testing
- Query optimization analysis

Should be avoided in routine production queries.

### 10. Query Analysis Using explain()

```javascript
db.students.find({ year: 2 }).explain("executionStats")
```

**Key Metrics:**

- Query execution plan
- Index usage
- Documents examined
- Execution time

A COLLSCAN indicates a potential optimization opportunity.

### 11. Index Trade-Offs and Write Performance

Indexes improve read performance but introduce overhead.

Every write operation must:

- Modify the document
- Update all associated indexes

Excessive indexing can:

- Slow inserts and updates
- Increase disk usage
- Consume additional memory

Index design must balance read performance and write cost.

### 12. Best Practices for Index Design

| Best Practice | Reason |
| :--- | :--- |
| Design based on real queries | Avoid unnecessary indexes |
| Use compound indexes | Serve multiple query patterns |
| Follow index order carefully | Respect the prefix rule |
| Monitor with explain() | Validate effectiveness |
| Remove unused indexes | Improve write performance |
| Balance reads and writes | Prevent system overload |

### 13. Final Summary

Indexing is the foundation of MongoDB performance optimization. Effective index design requires understanding:

- Query patterns
- Data growth
- Read/write workload
- Internal execution behavior

Indexing is not a syntactic feature — it is a core database engineering discipline essential for building scalable, production-grade systems.


