# **Deleting Documents in MongoDB (Careful & Intentional Deletes)**

Deleting data is the **most dangerous CRUD operation**.

* Inserts can be fixed
* Updates can sometimes be corrected
* **Deletes are permanent**

MongoDB will **not warn you**, **not ask for confirmation**, and **not keep backups** by default.

That’s why deletion must always be **intentional, filtered, and minimal**.

---

## **1. What Does “Delete” Mean in MongoDB?**

In MongoDB, **Delete** means:

> Permanently removing documents from a collection based on a condition

Once deleted:

* the document is gone
* it cannot be recovered
* future reads will never find it

---

## **Prerequisite: Insert Practice Documents**

Before practicing deletes, insert **known documents**.

```javascript
use codinggita

db.jobs.insertMany([
  {
    role: "Backend Developer",
    experience: 2,
    location: "Bangalore",
    isOpen: true
  },
  {
    role: "Frontend Developer",
    experience: 1,
    location: "Remote",
    isOpen: false
  },
  {
    role: "Full Stack Developer",
    experience: 3,
    location: "Bangalore",
    isOpen: false
  }
])
```

All delete examples below assume this data exists.

---

## **2. The Golden Rule of Deletes**

> **Never delete without reading first.**

Always run:

```javascript
db.jobs.find(filter)
```

before running:

```javascript
db.jobs.deleteOne(filter)
```

---

## **3. `deleteOne()` – Safest Delete Method**

### **Syntax**

```javascript
db.collection.deleteOne(filter)
```

---

### **Example: Delete One Closed Job**

```javascript
db.jobs.deleteOne({ isOpen: false })
```

What happens:

* MongoDB deletes **only the first matching document**
* Other matching documents remain untouched

---

### **Delete Result**

MongoDB returns:

```javascript
{
  acknowledged: true,
  deletedCount: 1
}
```

Always check `deletedCount`.

---

## **4. `deleteMany()` – Powerful and Dangerous**

### **Syntax**

```javascript
db.collection.deleteMany(filter)
```

---

### **Example: Delete All Closed Jobs**

```javascript
db.jobs.deleteMany({ isOpen: false })
```

This removes **all matching documents**.

⚠ There is **no undo**.

---

## **5. Delete Everything (DO NOT RUN)**

```javascript
db.jobs.deleteMany({})
```

This wipes the entire collection.

MongoDB will happily execute it.

---

## **6. Safe Delete Workflow (Mandatory)**

Always follow this order:

1. **Preview**

```javascript
db.jobs.find({ isOpen: false })
```

2. **Count**

```javascript
db.jobs.countDocuments({ isOpen: false })
```

3. **Delete**

```javascript
db.jobs.deleteMany({ isOpen: false })
```

This prevents accidental mass deletion.

---

## **7. Soft Delete (Industry Practice)**

In real systems, data is rarely deleted immediately.

Instead, it is **soft deleted**.

---

### **Soft Delete Example**

```javascript
db.jobs.updateOne(
  { role: "Frontend Developer" },
  { $set: { isDeleted: true } }
)
```

Now:

* data remains
* queries exclude deleted records
* recovery is possible

Example read:

```javascript
db.jobs.find({ isDeleted: { $ne: true } })
```

---

## **8. Common Beginner Mistakes**

### ❌ Deleting without checking filter

```javascript
deleteMany({ experience: 1 })
```

May delete more than expected.

---

### ❌ Using deleteMany instead of deleteOne

Accidental bulk deletion.

---

### ❌ Forgetting business rules

Deleting jobs that should be archived.

---

## **9. When Deleting Is Actually Needed**

Hard deletes are appropriate when:

* test data cleanup
* expired temporary data
* logs beyond retention period
* legally required removals

For most user data → **soft delete is safer**.

---

## **Key Takeaways**

After this article, you should understand:

* difference between `deleteOne()` and `deleteMany()`
* why deletes are irreversible
* how to preview before deleting
* how soft delete works
* why production systems avoid hard deletes

---
