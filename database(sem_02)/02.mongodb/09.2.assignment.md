# **Assignment – Projections & Pagination (Restaurant Dataset)**

**Dataset:** `restaurants` collection
**Records:** ~2,500 documents
**Goal:** Learn to **read large data safely and intentionally**

---

## **Part A – Warm-up (Understanding the Problem)**

Run the following command:

```javascript
db.restaurants.find()
```

Then answer (no code, plain text):

1. Approximately how many documents are returned?
2. Why is this approach dangerous in real applications?
3. What type of applications would completely break with this response?

---

## **Part B – Projection Practice (Field Control)**

### Task 1 – Minimal Listing View

Write a query that returns:

* `name`
* `rating`
* `type_of_food`

Exclude `_id`.

---

### Task 2 – Location-Based View

Write a query that returns:

* `name`
* `outcode`
* `postcode`

Exclude all other fields.

---

### Task 3 – Remove Unnecessary Field

Write a query that returns **all fields except `URL`**.

Then answer:

* When is exclusion-based projection useful?
* When is inclusion-based projection safer?

---

## **Part C – Sorting Practice (Ordering Matters)**

### Task 4 – Best Rated Restaurants First

Write a query to:

* fetch all restaurants
* sort by `rating` from **highest to lowest**

---

### Task 5 – Food Type Priority Sort

Write a query to:

* sort first by `type_of_food` (A → Z)
* then by `rating` (high → low)

Explain:

* Why multi-field sorting is common in backend APIs.

---

## **Part D – Pagination Practice (Mandatory at Scale)**

### Task 6 – First Page

Write a query that returns:

* only **10 restaurants**
* starting from the beginning

---

### Task 7 – Second Page

Write a query that returns:

* restaurants **11–20**

---

### Task 8 – Arbitrary Page Calculation

Assume:

* page size = 25
* page number = 4

Write the correct `skip()` and `limit()` query.

---

## **Part E – Real-World Combined Query**

### Task 9 – Production-Style Query

Write **one query** that:

* fetches only `Thai` restaurants
* returns only:

  * `name`
  * `rating`
  * `outcode`
* sorts by rating (high → low)
* returns **only 5 results**

This query should look like something a **real backend API** would run.

---

## **Part F – Observation & Thinking**

Answer briefly:

1. Why should projections always be used in list APIs?
2. What happens if pagination is skipped on large collections?
3. Why is sorting before pagination important?

---

## **Expected Skill After This Assignment**

After completing this assignment, you should be able to:

* Read large MongoDB collections safely
* Control response size using projections
* Order data meaningfully using sort
* Paginate results correctly
* Think like a backend developer, not a script runner

---

