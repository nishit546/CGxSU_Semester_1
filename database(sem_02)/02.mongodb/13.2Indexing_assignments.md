# MongoDB Indexing â€“ PRO Practical Assignment

> [!IMPORTANT]
> **Mandatory Instructions (Must Be Followed Strictly)**
> These rules are mandatory and reflect real production backend practices.

###  Data Source Rules

*   All questions must be solved using the provided **`jobs.json`** dataset only.
*   Creating new data is **strictly prohibited**.
*   Modifying existing documents is **NOT allowed**.
*   Inserting additional records into the collection is **NOT permitted**.

###  Database Configuration

*   **Database Name:** `codinggita`
*   **Collection Name:** `jobs`
*   **Data File:** `jobs.json`

> [!WARNING]
> **ðŸš« Usage Restrictions**
> *   Update operations are **strictly NOT allowed**.
> *   Delete operations are **strictly NOT allowed**.
> *   Aggregation operations are **strictly NOT allowed**.
> *   Only the **`find()`** method must be used for all queries.
> *   Students must use only MongoDB **query operators** covered in class.

###  Execution Rules

1.  Every query must first be written and executed in **Mongo Shell (`mongosh`)**.
2.  Output of each query must be **verified carefully**.
3.  If output is incorrect, the query must be corrected and re-tested.

###  Submission Process

1.  Only **verified queries** should be written on paper.
2.  Writing queries directly on paper **without testing** is NOT acceptable.
3.  Queries written on paper must **exactly match** verified Mongo Shell queries.

---

##  Assignment Questions

### ðŸ”¹ LEVEL 1: (Q1â€“Q7)

1.  **Create an index** to optimize fetching jobs located in **Bangalore**.
    *   Write the query and verify index usage using `explain("executionStats")`.
2.  **Create an index** to optimize fetching jobs for **Google**.
    *   Write the query and confirm index usage.
3.  **Create an index** to optimize fetching jobs with role **Backend Developer**.
    *   Verify index usage using **explain**.
4.  **Create an index** to optimize fetching jobs where **experience â‰¥ 5 years**.
    *   Analyze `docsExamined`.
5.  **Create an index** to optimize fetching **Full-time** jobs.
    *   Verify execution plan.
6.  **Create an index** to optimize fetching jobs where **salary > 30 LPA**.
    *   Compare `executionStats` before and after index.
7.  **Identify one created index** that provides minimal benefit.
    *   Drop it and justify using **explain output**.

---

### ðŸ”¹ LEVEL 2: (Q8â€“Q14)

8.  Write a query to **sort jobs by salary** in descending order **without any index**.
    *   Observe execution behavior.
9.  **Create an index** to optimize salary-based sorting.
    *   Re-run the same query and verify improvement.
10. Write a query to fetch the **top 5 highest paid jobs** and verify index usage.
11. Write a query to **sort jobs by experience** in ascending order.
12. **Create an index** to optimize experience-based sorting.
    *   Verify that sorting does not occur in memory.
13. Write a query to fetch the **lowest 3 salary jobs** using index.
14. Prove using **explain** that sorting is performed via index and **not a blocking sort**.

---

### ðŸ”¹ LEVEL 3: (Q15â€“Q22)

15. **Create an index** to optimize fetching **Backend Developer** jobs in **Bangalore**.
    *   Write the query and verify index usage.
16. Using the same index, write a query filtering **only by location** and verify behavior.
17. Write a query filtering **only by role** and analyze index usage.
18. **Create an index** to optimize filtering by **location** and sorting by **salary**.
19. Write a query to fetch **Bangalore** jobs sorted by **salary descending**.
    *   Prove one index handles both filter and sort.
20. **Create an index** to optimize fetching **Full-time** jobs with **experience > 3 years**.
21. **Create an index** to optimize filtering by **experience** and sorting by **salary**.
22. **Identify one poorly designed multi-field index**.
    *   Drop it and justify using `executionStats`.

---

### ðŸ”¹ LEVEL 4: (Q23â€“Q30)

23. **Create an index** to optimize searching inside the **skills** field.
    *   Write a query to fetch jobs requiring **MongoDB**.
24. Verify using **explain** how MongoDB handles **array-based indexing**.
25. Write a query to fetch jobs requiring **React** and verify index usage.
26. Write a query to fetch jobs requiring **Java**.
27. Write a query to fetch jobs requiring **both Node.js and MongoDB**.
28. Prove using **explain** that multiple index keys are evaluated for a single document.
29. Write a query to fetch jobs requiring **Kafka** and analyze `executionStats`.
30. Identify which **skills-based query** is the most expensive even after indexing and explain why.

---

### ðŸ”¹ LEVEL 5: (Q31â€“Q40)

31. **Create an index** that allows **keyword-based searching** on skills.
32. Write a query to **search jobs related to Java** and verify index usage.
33. Write a query to **search jobs related to System Design**.
34. Write a query to **search jobs related to Distributed Systems**.
37. Write a query combining **keyword search** with **salary > 30 LPA**.
38. Write a query combining **keyword search** with **location = Bangalore**.
39. Prove using **explain** that a normal index **cannot support keyword search**.
40. Drop the search index and observe how query behavior changes.

---

### ðŸ§  Interview Questions (Basic & Must-Know)

41. What is the difference between `COLLSCAN` and `IXSCAN`?
42. Why does **indexing improve read performance** but **slow down write operations**?
43. Why does MongoDB treat **array fields differently** while indexing?
44. What is Indexing in MongoDB ?
45. How do you decide **which fields should be indexed** in a real production system?
