# **MongoDB Basics: Core Concepts**

Before working with MongoDB queries and commands, it is essential to understand how MongoDB **stores, organizes, and relates data**. These core concepts form the foundation for everything you will do later—CRUD operations, indexing, aggregation, and schema design.

In this section, we will focus on:

* MongoDB’s data hierarchy
* Databases, collections, and documents
* BSON (MongoDB’s internal data format)
* The schema-less nature of MongoDB
* Ways to model related data using embedding and referencing

By the end of this article, you should be able to **visualize how data lives inside MongoDB** and clearly explain how it differs from relational databases.

---

## **1. Data Hierarchy: Database, Collection, and Document**

MongoDB follows a simple and flexible data hierarchy that is different from the table-based structure used in relational databases.

```
Database → Collection → Document
```

Instead of rows and columns, MongoDB works with **documents grouped inside collections**, which exist inside a database.

---

### **Database**

A **database** is the top-level container in MongoDB.
A single MongoDB server can host multiple databases, each usually representing one application or system.

A database contains:

* Multiple collections
* No fixed limit on the number of collections

Example database:

* `CodingGitaBTechDB`

---

### **Collection**

A **collection** is a group of related documents.
It is similar to a table in a relational database, but **without a fixed schema**.

Important points:

* Documents in the same collection can have different fields
* MongoDB does not enforce column definitions like SQL tables

Example collection:

* `students`

---

### **Document**

A **document** is a single record stored in MongoDB.
Documents are stored in **BSON format** and consist of key–value pairs.

Example document stored inside the `students` collection:

```json
{
  "name": "Arjun",
  "rollNumber": "12345",
  "department": "CSE",
  "year": 3,
  "coursesEnrolled": ["Data Structures", "DBMS", "AI"],
  "age": 21
}
```

In this example:

* Each student is represented as **one complete document**
* Related data is grouped together
* No table joins are required to fetch student details

In relational databases, this same data would require predefined columns and possibly multiple tables.

---

## **2. Introduction to BSON**

MongoDB does not store data as plain JSON internally.
Instead, it uses **BSON (Binary JSON)** — a binary representation of JSON-like documents.

BSON is designed specifically to support:

* Faster storage
* Faster querying
* Rich data types

---

### **Why BSON Is Used**

MongoDB uses BSON because:

* **Efficiency**
  Binary data is faster to read and write compared to plain text JSON.

* **Additional Data Types**
  BSON supports data types such as:

  * `Date`
  * `ObjectId`
  * `Binary`
  * Embedded documents
  * Arrays

* **Better Indexing Support**
  BSON works efficiently with MongoDB’s indexing system.

---

### **BSON vs JSON**

* JSON is human-readable and used for data exchange.
* BSON is optimized for **internal database operations**.

Example BSON-style representation of a date:

```json
{
  "name": "Krishna",
  "enrollmentDate": { "$date": "2021-08-15T00:00:00Z" }
}
```

Here, the date is stored as a real date type instead of a string, allowing accurate comparisons and sorting.

---

## **3. Schema-less Nature of MongoDB**

MongoDB is often described as **schema-less**, but this does **not** mean data is unstructured or random.

What it actually means:

* MongoDB does not force a fixed schema at the database level
* Each document can evolve independently

---

### **Benefits of Schema-less Design**

* **Flexibility**
  Fields can be added or removed without modifying the entire collection.

* **Easy Evolution**
  As application requirements change, the data model can change without breaking existing records.

---

### **Example of Schema Evolution**

Initial document:

```json
{
  "name": "Priyasha",
  "rollNumber": "67890",
  "department": "CSE",
  "year": 2
}
```

Later, new information is required:

```json
{
  "name": "Priyasha",
  "rollNumber": "67890",
  "department": "CSE",
  "year": 2,
  "skills": ["Java", "MongoDB", "React"]
}
```

Older documents remain valid, and newer documents can store additional fields.

This approach is extremely useful in modern applications where requirements change frequently.

---

## **4. Embedded Documents and References**

When designing a MongoDB database, an important decision is **how to store related data**. MongoDB provides two main approaches:

1. **Embedding**
2. **Referencing**

---

### **Embedding Related Data**

Embedding means storing related data **inside the same document**.

Example:

```json
{
  "name": "Yashvi",
  "rollNumber": "112233",
  "department": "CSE",
  "year": 1,
  "courses": [
    {
      "courseCode": "CS101",
      "courseName": "Data Structures",
      "credits": 4,
      "instructor": "Prof. Singh"
    },
    {
      "courseCode": "CS102",
      "courseName": "Database Management Systems",
      "credits": 3,
      "instructor": "Dr. Sharma"
    }
  ]
}
```

**Embedding is preferred when:**

* Data is accessed together
* Relationships are one-to-few
* Fast read performance is important

---

### **Referencing Related Data**

Referencing means storing related data in **separate collections** and linking them using identifiers.

Example:

```json
{
  "name": "Yashvi",
  "rollNumber": "112233",
  "department": "CSE",
  "year": 1,
  "courses": [
    { "$ref": "courses", "$id": "CS101" },
    { "$ref": "courses", "$id": "CS102" }
  ]
}
```

**Referencing is preferred when:**

* Data is shared across many documents
* Data changes frequently
* Data size is large

---

## **Choosing Between Embedding and Referencing (Important Design Decision)**

Choosing whether to **embed** data or **reference** it is one of the most important decisions when designing a MongoDB schema. There is no universal rule—each approach has trade-offs related to performance, data duplication, and flexibility.

Understanding these trade-offs helps you design databases that scale well and remain easy to maintain.

---

### **Key Differences at a Glance**

| Aspect           | Embedding                   | Referencing                         |
| ---------------- | --------------------------- | ----------------------------------- |
| Data storage     | Stored in the same document | Stored in separate collections      |
| Read performance | Faster (single query)       | Slower (multiple queries or lookup) |
| Data duplication | Possible                    | Minimal                             |
| Data consistency | Easier                      | Requires careful updates            |
| Best for         | One-to-few relationships    | One-to-many / many-to-many          |

---

### **When Embedding Is a Better Choice**

Embedding is generally preferred when:

* Related data is **always accessed together**
* The embedded data is **small in size**
* The number of embedded items is **limited**
* Read performance is more important than storage efficiency

**Example scenarios:**

* Orders with items
* User profile with address
* Student with enrolled courses (limited number)

Embedding reduces the need for joins or lookups and improves read speed.

---

### **When Referencing Is a Better Choice**

Referencing is preferred when:

* Related data is **large**
* The same data is **shared across multiple documents**
* Data changes frequently and must stay consistent
* The relationship is **one-to-many** or **many-to-many**

**Example scenarios:**

* Products used in many orders
* Courses shared by many students
* Users linked to multiple roles or permissions

Referencing avoids duplication but may require additional queries.

---

### **Practical Rule of Thumb**

Use this simple rule when starting out:

* If data **belongs only to one document** → **Embed**
* If data is **shared or reused** → **Reference**

This rule covers most beginner-level use cases correctly.

---

### **Impact on Performance**

* **Embedding** improves read performance because all data is fetched in one query.
* **Referencing** may require additional queries or aggregation (`$lookup`), which can be slower.

However:

* Excessive embedding can lead to very large documents.
* MongoDB has a **16 MB document size limit**, which is important to remember.

---

### **Schema Design Is a Balance**

MongoDB does not force one approach.
In real applications, **both embedding and referencing are often used together**, depending on the access pattern.

Good MongoDB schema design focuses on:

* How data is queried
* How frequently data changes
* How large the data can grow

---
