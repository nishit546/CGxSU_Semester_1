# MongoDB Aggregation Framework


### 1. Introduction to MongoDB Aggregation Framework

In real-world applications, databases are not used only to store and retrieve data.
They are also required to process, analyze, and summarize data before sending it to applications or user interfaces.

Most backend systems need processed results such as totals, averages, grouped data, and reports rather than raw documents. MongoDB provides this capability through the **Aggregation Framework**.

The Aggregation Framework allows data processing to be performed inside the database, which improves performance and reduces the workload on application servers.

Aggregation is therefore a core concept in MongoDB and an essential skill for backend developers.

## 2. Need for Aggregation in Real-World Applications

### 2.1 Limitations of Normal Queries (`find()`)

Normal MongoDB queries are mainly used for:
* Filtering documents
* Fetching records
* Selecting specific fields

However, these queries are not suitable for analytical tasks.

#### 2.2 Problems That Cannot Be Solved Using `find()`

Standard queries cannot efficiently:
* Group documents
* Calculate total, average, minimum, or maximum values
* Generate summary reports
* Perform analytics on large datasets

#### 2.3 Real-World Example

**Problem:**
Calculate the total salary and average salary for each department.

This problem requires:
* Grouping documents by department
* Performing calculations
* Returning summarized output

Such problems cannot be solved efficiently using `find()` and therefore require aggregation.

## 3. Definition of Aggregation Framework

The MongoDB Aggregation Framework is a data processing system that uses a **pipeline** approach.

In this approach, data passes through multiple **stages**.
Each stage performs a specific operation and passes the result to the next stage.

This step-by-step processing makes aggregation powerful, flexible, and suitable for complex data analysis.

## 4. Aggregation Pipeline Structure

#### 4.1 General Syntax of Aggregation Pipeline

```javascript
db.collection.aggregate([
  { stage1 },
  { stage2 },
  { stage3 }
])
```

#### 4.2 Characteristics of Aggregation Pipelines

* Stages execute in sequence
* Output of one stage becomes input to the next
* Order of stages affects performance
* Pipelines describe **what** to do, not **how** to do it
* MongoDB optimizes execution internally where possible

Aggregation queries are usually built stage by stage to ensure correctness and efficiency.

## 5. Important Aggregation Stages

#### 5.1 `$match` Stage (Filtering Documents)

The `$match` stage filters documents based on conditions.

```javascript
db.jobs.aggregate([
  { $match: { location: "Bangalore" } }
])
```

**Importance of `$match`:**
* Reduces number of documents early
* Improves performance
* Minimizes memory usage
* Can use indexes when placed at the beginning

**Rule:**
Always apply filtering as early as possible.

#### 5.2 `$project` Stage (Selecting and Transforming Fields)

The `$project` stage controls which fields appear in the output and allows field transformation.

```javascript
db.students.aggregate([
  {
    $project: {
      name: 1,
      department: 1,
      _id: 0
    }
  }
])
```

**Purpose of `$project`:**
* Controls output structure
* Reduces unnecessary data
* Improves clarity of results
* Shapes API responses

#### 5.3 `$group` Stage (Grouping and Aggregation)

The `$group` stage is used to group documents and perform calculations.

```javascript
db.jobs.aggregate([
  {
    $group: {
      _id: "$department",
      totalSalary: { $sum: "$salaryLPA" },
      avgSalary: { $avg: "$salaryLPA" }
    }
  }
])
```

**How `$group` Works:**
* Documents are grouped using `_id`
* Accumulators calculate values for each group
* Output contains one document per group

**Common Accumulators:**
* `$sum`
* `$avg`
* `$min`
* `$max`
* `$count`
* `$push`
* `$addToSet`

**Important Rule:**
Every `$group` stage must contain an `_id` field.

#### 5.4 `$sort` Stage (Sorting Documents)

```javascript
db.jobs.aggregate([
  { $sort: { salaryLPA: -1 } }
])
```

**Notes on `$sort`:**
* Sorting large datasets is expensive
* Apply sorting after filtering
* Indexes help only in early stages

#### 5.5 `$skip` and `$limit` Stages (Pagination)

```javascript
db.jobs.aggregate([
  { $sort: { salaryLPA: -1 } },
  { $skip: 10 },
  { $limit: 5 }
])
```

**Use Cases:**
* Pagination
* Limiting result size
* Dashboard data

## 6. Example of a Complete Aggregation Pipeline

```javascript
db.jobs.aggregate([
  { $match: { location: "Bangalore" } },
  {
    $group: {
      _id: "$department",
      avgSalary: { $avg: "$salaryLPA" }
    }
  },
  { $sort: { avgSalary: -1 } }
])
```

**Explanation:**
1. Filters jobs in Bangalore
2. Groups data by department
3. Calculates average salary
4. Sorts departments by salary

This type of query is commonly used in reports and analytics dashboards.

## 7. `$unwind` Stage (Working with Arrays)

The `$unwind` stage breaks array fields into separate documents.

```javascript
db.students.aggregate([
  { $unwind: "$skills" }
])
```

**Use Cases:**
* Skill analysis
* Tag-based reporting
* Grouping array elements

## 8. `$lookup` Stage (Joining Collections)

The `$lookup` stage is used to combine data from multiple collections.

```javascript
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "customerDetails"
    }
  }
])
```

**Important Points:**
* Performs left outer join
* Stores result in an array
* Can impact performance if misused

## 9. `$addFields` Stage (Adding Computed Fields)

```javascript
db.jobs.aggregate([
  {
    $addFields: {
      annualSalary: { $multiply: ["$salaryLPA", 100000] }
    }
  }
])
```

**Difference Between `$addFields` and `$project`**

| `$addFields` | `$project` |
| :--- | :--- |
| Adds new fields | Reshapes output |
| Keeps existing fields | Can remove fields |

## 10. `$count` Stage (Counting Documents)

```javascript
db.jobs.aggregate([
  { $match: { location: "Delhi" } },
  { $count: "totalJobs" }
])
```

Used to count documents efficiently without returning full data.

## 11. Performance Considerations in Aggregation

Aggregation operations can be resource-intensive.

**Common Issues:**
* High memory usage
* Disk spilling
* CPU overhead

**Best Practices:**
* Use `$match` early
* Avoid unnecessary `$unwind`
* Limit `$lookup` usage
* Use indexes
* Analyze queries using `explain()`

## 12. Aggregation vs Application-Side Processing

| Aggregation | Application Processing |
| :--- | :--- |
| Faster for large data | Slower due to data transfer |
| Less network overhead | High network usage |
| Database optimized | Depends on application |

**Key Principle:**
Always process large datasets at the database level.

## 13. Summary

The MongoDB Aggregation Framework is a fundamental concept for real-world MongoDB applications.

Students should focus on:
* Understanding pipeline flow
* Learning key aggregation stages
* Writing efficient queries
* Applying aggregation to real problems

A strong understanding of aggregation is essential for backend development and interviews.
