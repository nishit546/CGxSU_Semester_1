# Graph API

## Graph API Explained

The Graph API is the **core interface** through which LangGraph applications are built. It is the foundation that transforms abstract ideas—such as nodes, edges, and state—into a **concrete, executable, and controllable system**.

If LangGraph is the framework, the Graph API is the **engine** that makes everything run.

---

## What the Graph API Is Responsible For

At a high level, the Graph API allows you to:

- Define the **structure of the shared state**
- Register **nodes** (units of work)
- Connect nodes using **edges** (control flow)
- Define **entry points** for execution
- Validate and **compile** the graph
- Execute the graph as a **runtime system**

Everything an agent does—thinking, deciding, acting—flows through the Graph API.

---

## Why the Graph API Exists

Traditional LLM applications rely on implicit execution:
- Prompts hide logic
- Control flow is scattered across code
- State is manually reassembled
- Debugging is difficult

The Graph API exists to enforce **engineering discipline**.

It ensures that:
- Execution order is explicit
- State flow is predictable
- Decisions are inspectable
- Errors are caught early
- Behavior is reproducible

This is what makes LangGraph suitable for **production systems**, not just demos.

---

## Step-by-Step: How the Graph API Is Used

### 1. Define the State Schema

The process always begins with defining the **state schema**.

The state schema is a **contract** for the entire graph:
- Every node reads from it
- Every node writes to it
- Every edge makes decisions based on it

Because the schema is explicit, the entire system becomes easier to reason about.

---

### 2. Create the Graph Object

Once the state schema is defined, you create a graph object.

This graph object:
- Knows how to store and pass state
- Keeps track of registered nodes
- Manages edges and routing logic
- Acts as the central coordinator

At this point, the graph is empty—it has structure, but no behavior yet.

---

### 3. Register Nodes

Next, you add nodes to the graph.

Each node:
- Is given a **unique name**
- Is mapped to a Python function
- Receives the current state
- Returns updates to the state

The Graph API does **not** care what happens inside the node.
It only enforces:
- Correct inputs
- Correct outputs
- Consistent state updates

This decoupling allows nodes to remain simple and testable.

---

### 4. Connect Nodes Using Edges

Edges define **how execution flows** through the graph.

This is where the Graph API truly shines.

You can define:
- Straight-line execution
- Conditional branching
- Retry loops
- Human-in-the-loop pauses
- Safe termination paths

Edges turn isolated nodes into a **coherent decision-making system**.

---

### 5. Define the Entry Point

Every graph needs a clear **starting point**.

The entry point tells LangGraph:
- Which node runs first
- Where execution begins

Without an entry point, the graph cannot run.

---

### 6. Compile the Graph

Compilation is a **critical step**.

When you compile the graph, the Graph API:

- Validates node names
- Ensures all edges point to valid nodes
- Confirms the entry point exists
- Checks that control flow is well-defined
- Prepares an optimized runtime structure

If something is wrong, compilation fails early—before runtime.

This prevents subtle and dangerous errors in production.

---

### 7. Execute the Graph

After compilation, the graph becomes a **runnable application**.

At runtime:
- State flows from node to node
- Nodes update state
- Edges decide the next step
- Execution continues until termination

The graph behaves like a **controlled runtime environment** for your agent.

---

## Example: Graph API Usage (Conceptual)


```python
# 1. Define state
class AgentState(TypedDict):
    task: str
    approved: bool

# 2. Create graph
graph = StateGraph(AgentState)

# 3. Add nodes
graph.add_node("process", process_node)
graph.add_node("review", review_node)

# 4. Add edges
graph.add_edge("process", "review")
graph.add_conditional_edges("review", approval_router)

# 5. Set entry point
graph.set_entry_point("process")

# 6. Compile graph
app = graph.compile()
```


## Example: Graph API

```python
#########################################################
# IMPORT REQUIRED LIBRARIES
#########################################################

# TypedDict is used to define structured state
from typing import TypedDict, Annotated

# add_messages is a reducer to append new messages
from langgraph.graph.message import add_messages

# StateGraph is the core LangGraph class for building graphs
# START and END define graph entry and exit points
from langgraph.graph import StateGraph, START, END

# Import a language model to use in nodes
from langchain_openai import ChatOpenAI


#########################################################
# DEFINE THE STATE FOR THE GRAPH
#########################################################

class ChatState(TypedDict):
    # Full conversation history stored in state
    messages: Annotated[list, add_messages]
    # Flag used for conditional edges
    approved: bool


#########################################################
# INITIALIZE THE LANGUAGE MODEL
#########################################################

# Create a deterministic LLM instance
llm = ChatOpenAI(
    model="gpt-4o-mini",
    temperature=0
)


#########################################################
# DEFINE NODES
#########################################################

def chatbot_node(state: ChatState):
    # Node reads current messages and generates a response
    response = llm.invoke(state["messages"])
    return {"messages": [response], "approved": False}


def human_review_node(state: ChatState):
    # Node asks human for approval
    user_input = input("Approve response? (y/n): ").strip().lower()
    return {"approved": user_input == "y"}


#########################################################
# BUILD THE GRAPH USING GRAPH API
#########################################################

# Create the StateGraph with the defined schema
graph = StateGraph(ChatState)

# Register nodes in the graph
graph.add_node("chatbot", chatbot_node)
graph.add_node("human_review", human_review_node)

# Define linear flow from START to chatbot, then human review
graph.add_edge(START, "chatbot")
graph.add_edge("chatbot", "human_review")

# Define conditional routing after human review
def approval_router(state: ChatState):
    if state["approved"]:
        return "end"      # finish if approved
    return "chatbot"      # loop back if not approved

graph.add_conditional_edges(
    "human_review",
    approval_router,
    {"chatbot": "chatbot", "end": END}
)

# Compile the graph into an executable app
app = graph.compile()


#########################################################
# RUN THE GRAPH
#########################################################

# Initialize state with a user message
initial_state = {
    "messages": [("user", "Explain LangGraph Graph API.")],
    "approved": False
}

# Invoke the graph
final_state = app.invoke(initial_state)

# Print the conversation
for role, message in final_state["messages"]:
    print(f"{role.upper()}: {message}")

```

---
