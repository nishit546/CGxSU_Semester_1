# Main Components in Graph Based Architecture:

## Nodes

In LangGraph, a **node** represents a **single, well-defined unit of work**. Conceptually, a node is one step in an agent’s reasoning, decision-making, or action process. Nodes are the *building blocks* of a LangGraph workflow.

A node is implemented as a **plain Python function**. It receives the current shared state as input and returns updates to that state as output. LangGraph automatically merges these updates back into the global state and passes the updated state to the next node in the graph.

---

## What a Node Represents

Think of a node as answering one clear question:

> **“What is the one thing I need to do at this step?”**

Examples of common node responsibilities include:
- Generating or updating a plan
- Calling an LLM for reasoning or text generation
- Using an external tool or API
- Asking a human for input
- Validating or evaluating results
- Deciding whether a task is complete

Each node should be **small, focused, and deterministic**.

---

## Why Nodes Should Be Small and Focused

LangGraph encourages nodes to do **one thing well** for several important reasons:

1. **Clarity**  
   When a node has a single responsibility, its purpose is immediately obvious.

2. **Reusability**  
   Small nodes can be reused across different workflows.

3. **Debuggability**  
   If something goes wrong, you know exactly which step caused the issue.

4. **Testability**  
   Nodes are just Python functions. You can test them independently without running the entire graph.

5. **Separation of Concerns**  
   Nodes perform work.  
   **Edges decide what happens next.**

This separation keeps workflows clean and maintainable.

---

## What Nodes Do *Not* Do

It is important to understand what nodes should **not** handle:

- Nodes do **not** decide the next step in the workflow  
- Nodes do **not** manage control flow  
- Nodes do **not** contain looping or branching logic  

All control flow is handled by **edges**, not nodes.

---

## Understanding State in Nodes

LangGraph workflows use a **shared state** that flows through the graph. Each node:
- Reads data it needs from the state
- Performs its task
- Returns only the data it wants to update

To make state predictable and safe, LangGraph commonly uses `TypedDict`.

---

## Example: A Simple LangGraph Node 


```python
#########################################################
# IMPORT REQUIRED LIBRARIES
#########################################################

# TypedDict allows us to define the exact structure
# of the shared state used across the graph
from typing import TypedDict


#########################################################
# DEFINE THE SHARED STATE STRUCTURE
#########################################################

class AgentState(TypedDict):
    """
    AgentState defines the shape of the shared data
    that flows between nodes in the LangGraph workflow.
    """

    # The task or input the agent is working on
    task: str

    # The result produced by this node
    result: str


#########################################################
# DEFINE A LANGGRAPH NODE
#########################################################

def process_task_node(state: AgentState) -> dict:
    """
    This function represents a single LangGraph node.

    Responsibilities of this node:
    - Read the task from the shared state
    - Perform a simple processing step
    - Return an updated value back to the state
    """

    # ---------------------------------------------------
    # STEP 1: Read data from the shared state
    # ---------------------------------------------------
    task = state["task"]

    # ---------------------------------------------------
    # STEP 2: Perform one focused unit of work
    # (In real-world usage, this could be an LLM call,
    # a tool execution, or a validation step)
    # ---------------------------------------------------
    processed_result = f"Task processed successfully: {task}"

    # ---------------------------------------------------
    # STEP 3: Return updates to the state
    # LangGraph automatically merges this with
    # the global workflow state
    # ---------------------------------------------------
    return {
        "result": processed_result
    }
```
## Edges

In LangGraph, **edges define control flow**. While nodes are responsible for *doing work*, edges are responsible for deciding **what happens next**. Without edges, nodes would exist in isolation with no execution order or logic connecting them.

If nodes are the *workers* of a LangGraph system, edges are the *decision-makers* that guide execution through the workflow.

---

## What Edges Do

Edges answer a critical question after each node runs:

> **“Which node should execute next, given the current state?”**

Edges do **not** perform reasoning, call LLMs, or use tools. Their sole responsibility is **routing**—deciding the next step in the graph.

---

## Why Edges Matter

Edges are what make LangGraph truly **agentic** rather than linear.

With edges, the system can:

- **Branch** based on decisions or outcomes  
- **Loop** until a condition is satisfied  
- **Retry** failed steps  
- **Pause** for human input  
- **Stop** execution intentionally and safely  

Without explicit edges, these behaviors would be hidden inside prompts or application logic, making systems unpredictable and hard to debug.

---

## Types of Edges in LangGraph

### 1. Direct Edges
A direct edge always routes execution from one node to another.  
This is similar to a fixed step in a pipeline.

Example:
- Node A → Node B → Node C

Direct edges are useful when the next step is always known and unconditional.

---

### 2. Conditional Edges
A conditional edge chooses the next node **based on the current state**.

This enables:
- Decision-making
- Branching logic
- Loops
- Safety checks
- Human approvals

Conditional edges are implemented as **routing functions**.

---

## Separation of Responsibilities

LangGraph enforces a strict and clean separation of concerns:

- **Nodes**
  - Perform work
  - Call LLMs or tools
  - Modify the shared state

- **Edges**
  - Read the shared state
  - Decide control flow
  - Never perform work

This separation keeps workflows understandable even as they grow complex.

---

## Understanding State in Edges

Edges rely on the **shared state** to make decisions.  
Just like nodes, edges commonly use `TypedDict` to make state structure explicit and safe.

Edges often inspect:
- Boolean flags
- Status values
- Validation results
- Retry counters
- Human approval signals

---

## Example: A Conditional Edge


```python
#########################################################
# IMPORT REQUIRED LIBRARIES
#########################################################

# TypedDict helps define the structure of the shared state
# so everyone knows what data is available
from typing import TypedDict


#########################################################
# DEFINE THE SHARED STATE STRUCTURE
#########################################################

class AgentState(TypedDict):
    """
    AgentState defines the data that flows
    through the LangGraph workflow.

    This particular edge only cares about
    whether something has been approved.
    """

    # A flag that determines which path
    # the graph should take next
    approved: bool


#########################################################
# DEFINE A CONDITIONAL EDGE (ROUTER FUNCTION)
#########################################################

def approval_router(state: AgentState) -> str:
    """
    This function represents a conditional edge.

    What it does:
    - Reads data from the shared state
    - Decides which node should run next
    - Returns the name of the next node

    What it does NOT do:
    - Perform any work
    - Call an LLM
    - Modify the state
    """

    # ---------------------------------------------------
    # STEP 1: Read the decision flag from the state
    # ---------------------------------------------------
    is_approved = state["approved"]

    # ---------------------------------------------------
    # STEP 2: Decide the control flow
    # ---------------------------------------------------
    if is_approved:
        # If approval is True,
        # route execution to the END of the graph
        return "end"

    # If approval is False,
    # route execution back to a retry node
    return "retry_node"
```
---

## State

State is the **shared memory** of a LangGraph application. It is the single source of truth that flows through the graph, carrying information from node to node. Without state, an agent would have no memory, no continuity, and no understanding of what has already happened.

If nodes are the *actions* and edges are the *decisions*, then **state is the memory that makes those actions and decisions meaningful**.

---

## What State Represents

State represents **everything the agent knows at a given moment**. This can include:

- The original task or goal  
- Conversation history  
- Intermediate reasoning results  
- Tool outputs  
- Decisions made so far  
- Flags used for control flow  
- Validation results  
- Human approvals or feedback  

Instead of repeatedly stuffing all context into prompts, LangGraph keeps this information in a **structured, persistent object** that naturally moves through the workflow.

---

## Why State Is Essential

Without state:
- The agent forgets previous steps  
- Nodes cannot build on earlier results  
- Conditional logic becomes impossible  
- Debugging becomes guesswork  

With state:
- Every step builds on the last  
- Decisions are explainable  
- Behavior is consistent and predictable  
- Long-running workflows become possible  

State is what allows LangGraph agents to behave **intelligently over time**, rather than producing isolated responses.

---

## Explicit and Typed State

LangGraph strongly encourages defining state **explicitly**, often using `TypedDict`.

This provides several advantages:
- You always know what data exists  
- Nodes agree on state structure  
- Missing or incorrect fields are caught early  
- The system becomes self-documenting  

When you read the state definition, you immediately understand what the agent can see and modify.

---

## Example: Defining State in LangGraph 

```python
#########################################################
# IMPORT REQUIRED LIBRARIES
#########################################################

# TypedDict allows us to define a strict structure
# for the shared state used across the graph
from typing import TypedDict, Annotated

# add_messages is a LangGraph reducer
# It controls how new values are merged into state
from langgraph.graph.message import add_messages


#########################################################
# DEFINE THE LANGGRAPH STATE
#########################################################

class AgentState(TypedDict):
    """
    AgentState defines all data that flows through
    the LangGraph workflow.

    Every node and edge relies on this structure
    to read and update information safely.
    """

    # ---------------------------------------------------
    # Conversation or message history
    # ---------------------------------------------------
    # Annotated + add_messages tells LangGraph:
    # - Do NOT overwrite existing messages
    # - Append new messages to the list instead
    messages: Annotated[list, add_messages]

    # ---------------------------------------------------
    # Control-flow decision flag
    # ---------------------------------------------------
    # This flag can be read by edges
    # to decide which path the graph should take
    approved: bool
```