# Tools in LangGraph
## Tools

Tools are what allow LangGraph agents to **interact with the outside world**. While LLMs excel at reasoning, pattern recognition, and language understanding, they are fundamentally limited to text generation. They cannot directly fetch real-time data, run calculations, access files, or trigger external systems.

Tools bridge this gap.

In LangGraph, a **tool** is any external function, service, or capability that an agent can invoke to perform a concrete action. Tools extend an agent’s abilities beyond thinking into **doing**.

---

## Why Tools Are Essential for Agentic AI

Agentic AI is about more than producing good answers—it is about **achieving goals**.

Without tools:
- Agents can only speculate
- Outputs are based on static knowledge
- Actions remain hypothetical
- Real-world automation is impossible

With tools:
- Agents can gather fresh information
- Agents can verify assumptions
- Agents can affect external systems
- Agents can close the loop between reasoning and action

Tools are what turn an LLM-powered system into an **active problem-solver**.

---

## Common Types of Tools

LangGraph does not restrict what a tool can be. Any callable capability can be a tool, including:

- **Web search tools**  
  Retrieve up-to-date information from the internet

- **Mathematical and logical tools**  
  Perform precise calculations, simulations, or validations

- **Database tools**  
  Query structured data sources for facts or records

- **File system tools**  
  Read, write, or modify files

- **API tools**  
  Interact with external services such as payment systems, CRMs, or analytics platforms

- **Internal business logic tools**  
  Execute domain-specific operations unique to your application

---

## How Tools Fit into LangGraph

LangGraph integrates tools in a **structured and controlled way**.

- Tools are typically called **inside nodes**
- The node decides **when** a tool should be used
- Inputs to the tool come from the shared state
- Outputs from the tool are written back to the state
- Future nodes can reason about those results

This ensures that tool usage is **intentional**, not accidental.

---

## Tool Usage Is Explicit and Traceable

One of LangGraph’s most important design principles is **explicitness**.

Every tool invocation:
- Happens in a known node
- Has clear inputs
- Produces visible outputs
- Updates the shared state

Because of this:
- You can trace exactly when a tool was used
- You can explain why it was used
- You can inspect what result it returned
- You can audit the system’s behavior

This is critical for **debugging, compliance, and safety**.

---

## Reasoning + Tools = Action

A typical agentic loop involving tools looks like this:

1. The agent reasons about the task
2. It decides what information or action is needed
3. It selects an appropriate tool
4. The tool is executed
5. The result is stored in state
6. The agent reasons about the outcome
7. The next step is chosen

This tight feedback loop is what enables intelligent behavior over time.

---

## Tools and Safety

Uncontrolled tool usage can be dangerous.

LangGraph mitigates this by:
- Keeping tool calls inside nodes
- Routing decisions through edges
- Allowing validation before and after tool usage
- Supporting human-in-the-loop checkpoints
- Making all actions inspectable

This allows developers to **safely expose powerful capabilities** without sacrificing control.

---

## Mental Model for Tools

You can think of tools as:

> **The hands of an agent**

- The LLM provides the brain  
- The graph provides the structure  
- Tools provide the ability to act  

Without tools, an agent can think but cannot change anything.

---

## Tools Enable Real-World Use Cases

With tools, LangGraph agents can:

- Conduct live research
- Automate workflows
- Analyze real data
- Trigger business processes
- Monitor systems
- Assist humans with actionable outcomes

This is where agentic AI moves from theory to **practical value**.

---

## Key Takeaway

Tools are not optional in agentic systems—they are **foundational**.

LangGraph’s structured approach to tool usage ensures that:
- Actions are deliberate
- Behavior is explainable
- Systems are safe
- Outcomes are reliable

Tools transform LangGraph agents from passive text generators into **active, capable, real-world agents**.

---

## Example: Tools
```python
#########################################################
# IMPORT REQUIRED LIBRARIES
#########################################################

# TypedDict defines structured state
from typing import TypedDict, Annotated

# add_messages appends messages to conversation state
from langgraph.graph.message import add_messages

# Core LangGraph components
from langgraph.graph import StateGraph, START, END

# Prebuilt tool for basic calculator
from langchain.tools import tool

# Import LLM for node responses
from langchain_openai import ChatOpenAI


#########################################################
# DEFINE THE STATE
#########################################################

class ChatState(TypedDict):
    # Stores conversation history
    messages: Annotated[list, add_messages]

    # Stores output from tools
    tool_result: str


#########################################################
# INITIALIZE THE LLM
#########################################################

llm = ChatOpenAI(
    model="gpt-4o-mini",
    temperature=0
)


#########################################################
# DEFINE A CUSTOM TOOL (MULTIPLICATION)
#########################################################

@tool
def multiply_numbers(a: int, b: int) -> str:
    """
    This is a custom LangGraph tool that multiplies two numbers.
    Returns the result as a string to be stored in state.
    """
    result = a * b
    return str(result)


##########

```

---
