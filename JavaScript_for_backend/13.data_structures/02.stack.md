# **2: Stack**

## From Array to Stack (A Natural Step)

In the previous article, you saw that arrays can store **data and functions**, and that **order matters**.

Now we ask a simple question:

> What if we use an array, but **restrict how we access it**?

That restriction creates something very powerful:

**The Stack**

---

## What Is a Stack (Without Any New Fear)

A stack is **just an array** with one strict rule:

* Add items at one end
* Remove items from the **same end**

This rule is called **LIFO**:

> **Last In, First Out**

---

## Visualizing a Stack Using an Array

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20230116192305/stack-768.png?utm_source=codinggita.com)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20231130114919/LIFO-Operations-in-stack.jpg?utm_source=codinggita.com)

Think of stacking books:

* You place a book on top
* You remove the top book first

That’s exactly how a stack works.

---

## Stack Operations (You Already Know Them)

### push() — Put something on the stack

```js
stack.push("functionA");
```

### pop() — Remove the top item

```js
stack.pop();
```

That’s it.
No new syntax. Just **discipline**.

---

## The JavaScript Call Stack (This Is the Big One)

JavaScript uses a stack internally called the **Call Stack**.

Every time a function runs:

* It is **pushed** onto the stack
* When it finishes, it is **popped** off

---

## Simple Call Stack Example

```js
function first() {
  second();
}

function second() {
  third();
}

function third() {
  console.log("Hello");
}

first();
```

### What Happens Internally

![Image](https://miro.medium.com/v2/resize%3Afit%3A1200/1%2A2YEyFoFdgP1oVqq9ch1DTQ.jpeg?utm_source=codinggita.com)

![Image](https://youshaohua.com/assets/img/post/simply-and-easily-understanding-function-call-stack-by-a-vision/thum.jpg?utm_source=codinggita.com)

Execution order:

1. `first()` pushed
2. `second()` pushed
3. `third()` pushed
4. `third()` finishes → popped
5. `second()` finishes → popped
6. `first()` finishes → popped

---

## Why JavaScript Is Single-Threaded

JavaScript has **one call stack**.

This means:

* Only **one function executes at a time**
* No parallel execution on the stack

![Image](https://substackcdn.com/image/fetch/%24s_%21Hpgd%21%2Cf_auto%2Cq_auto%3Agood%2Cfl_progressive%3Asteep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4acd86f6-0764-48b8-87ac-f76acdd723cf_800x450.png?utm_source=codinggita.com)

![Image](https://static.wixstatic.com/media/1af9b8_29fb337cd2b3490996cb3be50a8892a9~mv2.jpg/v1/fill/w_568%2Ch_408%2Cal_c%2Cq_80%2Cusm_0.66_1.00_0.01%2Cenc_avif%2Cquality_auto/1af9b8_29fb337cd2b3490996cb3be50a8892a9~mv2.jpg?utm_source=codinggita.com)

This design makes JavaScript:

* Predictable
* Safe for browsers

But it also creates a problem…

---

## The Problem: Blocking the Stack

Consider this:

```js
while (true) {}
```

What happens?

* The stack never clears
* No other code runs
* Browser freezes

This is why **long-running synchronous code is dangerous**.

---

## Where Async Changes the Game

Now the key realization:

> **Async code does NOT stay on the stack.**

Example:

```js
setTimeout(() => {
  console.log("Async task");
}, 1000);
```

What happens:

* `setTimeout` goes on the stack
* JS registers the callback
* `setTimeout` exits the stack
* Stack becomes free again

The callback does **not** stay on the stack.

---

## Visualizing Sync vs Async on the Stack

![Image](https://refine.ams3.cdn.digitaloceanspaces.com/blog/2024-02-16-async-vs-sync/diagram.png?utm_source=codinggita.com)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/0%2AiHLzfmlOAroed4Bz.gif?utm_source=codinggita.com)

This is how JavaScript stays responsive while handling async work.

---

## Stack Overflow (Important but Simple)

When too many function calls pile up:

```js
function recurse() {
  recurse();
}

recurse();
```

The stack grows until memory limit → **stack overflow error**.

Why this matters for async:

* Async code avoids deep stack usage
* Callbacks resume later, not recursively

---

## Key Mental Model (Very Important)

Say this clearly to students:

> The stack is for **now**.
> Async work is for **later**.

If it’s “now” → stack
If it’s “later” → not stack

---

## How Stack Prepares You for Async JS

After this article, you now understand:

* How JS executes functions
* Why execution order matters
* Why async code doesn’t block
* Why JS needs queues

This naturally leads to the next question:

> If async work doesn’t stay on the stack… **where does it wait?**

---

## Quick Recap

* Stack = array with LIFO rule
* JavaScript uses a **call stack**
* Only one function runs at a time
* Async code exits the stack quickly
* Blocking the stack freezes everything

---
