# **6: Heap — Where JavaScript Stores Data During Async Execution**

## Stack vs Heap (Why Two Different Places Exist)

JavaScript uses two main memory areas:

* **Stack** → for execution
* **Heap** → for storage

The stack decides **what runs now**.
The heap decides **what stays in memory**.

Both are required to understand async behavior.

---

## What Is the Heap in JavaScript

The heap is a large memory area where JavaScript stores:

* Objects
* Arrays
* Functions
* Closures
* Promises

Unlike the stack:

* Heap memory is not removed immediately
* Data stays until it is no longer needed

---

## Visualizing Stack and Heap Together

![Image](https://felixgerschau.com/static/b452488bd7eeac0405c48f164da6280d/5a190/stack-heap-pointers.png?utm_source=codinggita.com)

![Image](https://i.imgur.com/kSgatSL.png?utm_source=codinggita.com)

In simple terms:

* Stack holds references
* Heap holds actual data

---

## Why the Heap Is Important for Async Code

Async code pauses execution but does **not** delete data.

Example:

```js
async function loadData() {
  const user = { name: "Aarav" };
  await fetch("/api/user");
  console.log(user.name);
}
```

Here:

* Function execution pauses at `await`
* The `user` object remains in memory
* Execution resumes later using the same data

This is possible only because data lives in the **heap**.

---

## Closures and Heap Memory

Closures work because referenced variables stay in the heap.

```js
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const fn = outer();
fn();
fn();
```

Even after `outer()` finishes:

* `count` remains stored
* `inner()` can access it later

This behavior is essential for async callbacks.

---

## Heap and Promises

Promises store their internal data in heap memory, such as:

* Current state
* Resolved value or error
* Registered handlers

Conceptually:

```js
{
  state: "fulfilled",
  value: data,
  handlers: [...]
}
```

This data remains accessible until the promise lifecycle is complete.

---

## Memory Cleanup (High-Level View)

JavaScript uses **garbage collection** to free heap memory.

* Data not referenced anymore is removed
* Active async operations keep references alive
* Forgotten listeners or timers can cause memory leaks

Understanding the heap helps avoid such issues.

---

## How Heap Fits into Async Execution

```
Stack → executes code
Heap  → stores data
Queue → waits for execution
```

Async JavaScript works because:

* Execution can pause
* Data does not disappear

---

## Summary

* Stack handles execution
* Heap handles storage
* Async code pauses execution, not memory
* Objects, closures, and promises live in the heap
* Heap memory enables async continuation

---

