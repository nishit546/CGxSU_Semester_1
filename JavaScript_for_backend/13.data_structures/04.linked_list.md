# **4: Linked List**

## Why We Even Need Another Data Structure

Till now, we’ve used **arrays** to understand:

* Stack (LIFO)
* Queue (FIFO)

And that’s perfectly fine **conceptually**.

But now comes a very honest question:

> If queues are so important in async JavaScript,
> **do engines really use arrays internally?**

The answer is: **not always**.

To understand why, we need one more idea — **Linked List**.

---

## The Real Problem with Arrays in Queues

Let’s recall what happens in a queue:

```js
queue.shift();
```

This removes the **first element**.

### What Actually Happens Internally

![Image](https://goodly.co.in/wp-content/uploads/2016/07/Screen1.png?utm_source=codinggita.com)

![Image](https://www.w3resource.com/w3r_images/c-programming-basic-algorithm-image-exercises-68.svg?utm_source=codinggita.com)

When you remove the first element:

* Every remaining element shifts left
* Indexes change
* Extra work is done

For **small queues**, this is fine.
For **large queues** (like async task queues), this becomes expensive.

So the question becomes:

> Can we remove items from the front **without shifting everything**?

That’s where Linked Lists come in.

---

## What Is a Linked List 

A linked list is **not index-based** like an array.

Instead:

* Data is stored in **nodes**
* Each node knows **who comes next**

Think of it as people holding hands in a line.

---

## Visualizing a Linked List

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20250619155958124670/Linked-list.webp?utm_source=codinggita.com)

![Image](https://miro.medium.com/1%2AiiEWrP2IznA6HbmuIdK0lQ.png?utm_source=codinggita.com)

Each node has:

* A value
* A reference to the next node

There are **no indexes** like 0, 1, 2.

---

## Why Linked Lists Are Perfect for Queues

In a queue, we need two things:

* Add at the end
* Remove from the front

With a linked list:

* Adding at the tail is fast
* Removing from the head is fast
* No shifting required

![Image](https://iq.opengenus.org/content/images/2019/03/Untitled-Diagram--3-.png?utm_source=codinggita.com)

![Image](https://d14qv6cm1t62pm.cloudfront.net/ccbp-website/Blogs/home/queue-using-linked-list-in-c-image-2.png?utm_source=codinggita.com)

This is why many internal queue implementations prefer linked lists.

---

## Important Clarification 

You are **not** expected to:

* Implement linked lists in JavaScript
* Write complex node-based code
* Learn algorithms like reversal or traversal

This article exists to explain **why engines choose certain structures**, not to turn you into a DSA expert.

---

## How This Connects to Async JavaScript

Now connect the dots:

* Async callbacks wait in queues
* Queues must be fast
* Fast queues avoid array shifting
* Linked lists solve this problem

So internally, JavaScript engines use **data structures inspired by linked lists** to manage async tasks efficiently.

---

## What You Should Remember 

> Arrays are great for learning.
> Linked lists are great for performance.

---

## Arrays vs Linked Lists (Mental Comparison)

| Feature           | Array      | Linked List   |
| ----------------- | ---------- | ------------- |
| Index access      | Fast       | Not available |
| Insert at end     | Fast       | Fast          |
| Remove from front | Slow       | Fast          |
| Memory layout     | Continuous | Scattered     |

No need to memorize — just understand **why choices are made**.

---

## Quick Recap

* Arrays are conceptually used for queues
* Removing from front of arrays is costly
* Linked lists avoid shifting
* Queues internally prefer linked-list-like behavior
* This improves async performance

---
