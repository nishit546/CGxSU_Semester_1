
# Promises in JavaScript

## Why Promises Were Introduced

Promises were introduced to **solve the problems of callback hell**.

With callbacks:

* Code becomes deeply nested
* Error handling is repetitive
* Readability suffers

Promises allow us to write **asynchronous code in a flat, readable, and maintainable way**.

---

## What is a Promise?

A **Promise** represents a value that will be available **now, later, or never**.

A promise has **three states**:

1. **Pending** – operation is in progress
2. **Fulfilled** – operation completed successfully
3. **Rejected** – operation failed

Once a promise is fulfilled or rejected, its state **cannot change**.

---

## Creating a Promise (Basic Example)

```javascript
const myPromise = new Promise(function (resolve, reject) {
  const success = true;

  if (success) {
    resolve("Task completed successfully");
  } else {
    reject("Task failed");
  }
});

myPromise
  .then(function (message) {
    console.log(message);
  })
  .catch(function (error) {
    console.log(error);
  });
```

### Key Points

* `resolve()` → success
* `reject()` → failure
* `.then()` → handles success
* `.catch()` → handles error

---

## Promise with `fetch` (FakeStore API – Single API Call)

Let’s fetch products from the FakeStore API.

### API Endpoint

```
https://fakestoreapi.com/products
```

### Code Example

```javascript
fetch("https://fakestoreapi.com/products")
  .then(function (response) {
    return response.json();
  })
  .then(function (data) {
    console.log("Products:", data);
  })
  .catch(function (error) {
    console.log("Error fetching products:", error);
  });
```

### What’s Happening Step-by-Step

1. `fetch()` returns a **Promise**
2. First `.then()` converts response to JSON
3. Second `.then()` gets actual data
4. `.catch()` handles any error

---

## Chaining Promises (Solving Callback Hell)

Promises allow **chaining**, where each `.then()` runs **after the previous one completes**.

### Scenario

1. Fetch all products
2. Pick first product
3. Fetch details of that product

---

### Code Example (Promise Chaining)

```javascript
fetch("https://fakestoreapi.com/products")
  .then(function (response) {
    return response.json();
  })
  .then(function (products) {
    console.log("All Products Fetched");
    return products[0].id;
  })
  .then(function (productId) {
    return fetch("https://fakestoreapi.com/products/" + productId);
  })
  .then(function (response) {
    return response.json();
  })
  .then(function (productDetails) {
    console.log("First Product Details:", productDetails);
  })
  .catch(function (error) {
    console.log("Error occurred:", error);
  });
```

### Why This is Better Than Callbacks

* No deep nesting
* Clean top-to-bottom flow
* Centralized error handling
* Easy to extend

---

## Handling Errors in Promises

Any error inside the chain automatically jumps to `.catch()`.

```javascript
fetch("https://fakestoreapi.com/invalid-url")
  .then(function (response) {
    return response.json();
  })
  .then(function (data) {
    console.log(data);
  })
  .catch(function (error) {
    console.log("Something went wrong:", error);
  });
```

You don’t need error checks at every step — **one `.catch()` is enough**.

---

## Promise vs Callback (Quick Comparison)

| Callbacks             | Promises          |
| --------------------- | ----------------- |
| Nested structure      | Flat structure    |
| Hard to read          | Easy to read      |
| Multiple error checks | Single `.catch()` |
| Difficult to scale    | Easy to extend    |

---

## Important Promise Methods

* `.then()` → success handling
* `.catch()` → error handling
* `.finally()` → runs always

Example:

```javascript
fetch("https://fakestoreapi.com/products")
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.log(err))
  .finally(() => console.log("API call completed"));
```

---

## Key Takeaways

* Promises solve callback hell
* They represent future values
* Promise chaining keeps code clean
* `fetch()` is promise-based by default
* Centralized error handling improves reliability

---

