
# Callback Hell in JavaScript

## What is Callback Hell?

**Callback Hell** happens when multiple callbacks are **nested inside each other**, making the code:

* Hard to read
* Hard to debug
* Hard to maintain

This usually occurs when we try to perform **multiple asynchronous tasks in sequence**, where each task depends on the result of the previous one.

A common name for this problem is the **“Pyramid of Doom”** because the code structure keeps shifting to the right.

---

## Why Does Callback Hell Occur?

JavaScript is **asynchronous** by nature.

When we have:

* Step 1 → wait → Step 2 → wait → Step 3 → wait

And each step depends on the previous one, developers often write code like:

```text
Task 1
  └─ Task 2
       └─ Task 3
            └─ Task 4
```

This nesting creates callback hell.

---

## Problems Caused by Callback Hell

1. Poor readability
2. Difficult error handling
3. Hard to reuse code
4. Debugging becomes complex
5. Code grows horizontally instead of vertically

---

## Code Example 1: Basic Callback Hell (Sequential Tasks)

### Scenario

We want to:

1. Login user
2. Fetch user profile
3. Fetch user orders

Each step depends on the previous one.

### Code

```javascript
function loginUser(username, callback) {
  setTimeout(function () {
    console.log("User logged in:", username);
    callback(username);
  }, 1000);
}

function getUserProfile(username, callback) {
  setTimeout(function () {
    console.log("Profile fetched for:", username);
    callback({ name: username, role: "Developer" });
  }, 1000);
}

function getUserOrders(profile, callback) {
  setTimeout(function () {
    console.log("Orders fetched for:", profile.name);
    callback(["Order1", "Order2"]);
  }, 1000);
}

// Callback Hell starts here
loginUser("Arjun", function (username) {
  getUserProfile(username, function (profile) {
    getUserOrders(profile, function (orders) {
      console.log("Final Orders:", orders);
    });
  });
});
```

### What’s Wrong Here?

* Deep nesting
* Each function depends on the previous callback
* Adding one more step increases complexity drastically

---

## Code Example 2: Realistic Callback Hell with Errors

### Scenario

We want to:

1. Read user ID
2. Fetch user details
3. Save activity log
4. Send confirmation

### Code

```javascript
function getUserId(callback) {
  setTimeout(function () {
    callback(null, 101);
  }, 500);
}

function getUserDetails(userId, callback) {
  setTimeout(function () {
    callback(null, { id: userId, name: "Krishna" });
  }, 500);
}

function saveLog(user, callback) {
  setTimeout(function () {
    callback(null, "Log saved");
  }, 500);
}

function sendEmail(callback) {
  setTimeout(function () {
    callback(null, "Email sent");
  }, 500);
}

// Callback Hell with error handling
getUserId(function (error, userId) {
  if (error) {
    console.log("Error getting userId");
    return;
  }

  getUserDetails(userId, function (error, user) {
    if (error) {
      console.log("Error getting user details");
      return;
    }

    saveLog(user, function (error, logStatus) {
      if (error) {
        console.log("Error saving log");
        return;
      }

      sendEmail(function (error, emailStatus) {
        if (error) {
          console.log("Error sending email");
          return;
        }

        console.log("Process completed successfully");
      });
    });
  });
});
```

### Problems Clearly Visible

* Repeated error checks
* Too many nested blocks
* Very difficult to modify
* One small change affects many levels

---

## Why This is Bad in Large Applications

In real projects:

* APIs call other APIs
* Database calls depend on authentication
* Logging and notifications run in sequence

Using nested callbacks here leads to:

* Fragile code
* Developer frustration
* Bugs during maintenance

---

## How Developers Solve Callback Hell (Concept Only)

We will cover these **in detail later**, but at a high level:

1. Split callbacks into separate functions
2. Use Promises
3. Use `async / await`

Callback hell is the **main reason** Promises and `async/await` exist.

---

## Key Takeaways

* Callback hell is excessive nesting of callbacks
* Happens in sequential async operations
* Makes code unreadable and hard to maintain
* Should be avoided in real-world projects

---

