# **Block Scope, Lexical Environment, and Shadowing (Deep Dive)**

Understanding how JavaScript manages variable scope is one of the most important parts of mastering the language.

This article explains:

* How variables "live" inside blocks
* How JavaScript stores and looks up variables
* What Lexical Environment is
* How Shadowing works (legal and illegal)
* Why var behaves incorrectly
* How let and const fix long-standing problems

---

# **1. What Is Scope in JavaScript?**

Scope determines:

* *Where a variable is accessible*
* *Which parts of the program can read or modify a value*

JavaScript has:

* Global Scope
* Function Scope
* Block Scope (ES6: let and const)

This article focuses on **Block Scope**, the foundation of modern JS.

---

# **2. What Is a Block?**

A block is anything written inside **curly braces** `{ }`.

Examples of blocks:

```javascript
{
}

if (condition) {
}

for (...) {
}

while (...) {
}

function test() { 
    // this is a function block
}
```

Blocks create **new variable environments** when using let and const.

---

# **3. Block Scope (let and const)**

Variables declared with **let** and **const** exist **only within the block** where they are defined.

### Example 1: Basic Block Scope

```javascript
{
    let x = 10;
    const y = 20;
    console.log(x, y); // 10 20
}

console.log(x); // Error
console.log(y); // Error
```

`x` and `y` only live inside the block.

---

### Example 2: Block Scope inside if

```javascript
if (true) {
    let student = "Krishna";
    console.log(student); // Krishna
}
console.log(student); // Error
```

---

### Example 3: Block Scope inside loops

```javascript
for (let i = 1; i <= 3; i++) {
    console.log(i);
}

console.log(i); // Error
```

---

# **4. var Does NOT Have Block Scope**

Before ES6, `var` had only **function scope**.

It does not care about blocks.

### Example 1:

```javascript
{
    var a = 50;
}

console.log(a); // 50
```

a escapes the block.

---

### Example 2: var inside if-block

```javascript
if (true) {
    var name = "Arjun";
}
console.log(name); // Arjun
```

---

### Example 3: Unexpected behavior inside loops

```javascript
for (var i = 0; i < 3; i++) {}
console.log(i); // 3
```

i leaks outside the loop.

This is one big reason modern JavaScript developers avoid var entirely.

---

# **5. Lexical Environment (Deep Dive)**

**Lexical Environment** is the internal structure that JavaScript uses to store variables for each block, function, or scope.

Every scope has its own Lexical Environment, which contains:

* Environment Record (variables, constants, functions)
* Reference to parent Lexical Environment (outer scope)

You can think of it like:

```
Block → Has its own variable table
Function → Has its own variable table
Global Scope → Top-most table
```

---

# **6. Lexical Environment Diagram**

Consider this code:

```javascript
let a = 10;

{
    let b = 20;

    {
        let c = 30;
        console.log(a, b, c);
    }
}
```

### **Lexical Environment Chain:**

```
Global (a)
   |
Block-1 (b)
   |
Block-2 (c)
```

Each inner block can access the outer variables,
but the outer block cannot access inner variables.

---

# **7. How Variable Lookup Works**

When JavaScript sees `console.log(c)`:

1. Look in current block
2. If not found → search parent block
3. If still not found → search further up
4. Continue until global scope
5. If not found anywhere → ReferenceError

This process is known as **scope chain lookup**.

---

# **8. Example of Scope Chain Lookup**

```javascript
let x = 10;

{
    let y = 20;

    {
        let z = 30;
        console.log(x + y + z); // 60
    }
}
```

Lookup steps:

* z → found in inner block
* y → found in parent block
* x → found in global block

This is how nested blocks communicate variables.

---

# **9. Shadowing in JavaScript**

Shadowing happens when:

* A variable in an inner scope
* Has the **same name** as a variable in an outer scope
* The inner variable **overrides** the outer variable *within that inner scope*

### Example 1: let shadowing let

```javascript
let a = 10;

{
    let a = 20;  // shadowing
    console.log(a); // 20
}

console.log(a); // 10
```

---

### Example 2: const shadowing const

```javascript
const city = "Ahmedabad";

{
    const city = "Surat"; // shadowing
    console.log(city); // Surat
}

console.log(city); // Ahmedabad
```

---

### Example 3: let shadowing const

```javascript
const course = "CSE";

{
    let course = "AIML";
    console.log(course); // AIML
}

console.log(course); // CSE
```

---

# **10. Illegal Shadowing**

Illegal shadowing happens when:

* Outer variable uses let or const
* Inner variable tries to declare with var
* This attempts to redeclare the same variable in the same function scope

Example:

```javascript
let x = 10;

{
    var x = 20; // Illegal shadowing
}
```

Why illegal?

* let creates block scope
* var ignores block scope and tries to redeclare x in the function/global scope

JavaScript throws an error to prevent this.

---

# **11. Legal vs Illegal Shadowing Summary**

| Outer Variable | Inner Variable | Legal? |
| -------------- | -------------- | ------ |
| let            | let            | Yes    |
| let            | const          | Yes    |
| const          | let            | Yes    |
| const          | const          | Yes    |
| var            | let            | Yes    |
| var            | const          | Yes    |
| let            | var            | No     |
| const          | var            | No     |

---

# **12. Practical Examples**

### Example 1: Student count shadowing

```javascript
let totalStudents = 50;

{
    let totalStudents = 60; // shadowing
    console.log(totalStudents); // 60
}

console.log(totalStudents); // 50
```

---

### Example 2: Batch code shadowing

```javascript
const batch = "CSE-2025";

{
    const batch = "AI-2025"; // new scope
    console.log(batch); // AI-2025
}

console.log(batch); // CSE-2025
```

---

### Example 3: Illegal shadowing

```javascript
let center = "Ahmedabad";

{
    var center = "Vadodara"; // Error
}
```

---

# **13. Deep Dive: Why var Shadowing Let Is Illegal**

JavaScript cannot allow:

```javascript
let a = 10;

{
    var a = 20;
}
```

Because:

* var declarations are lifted to the nearest function scope
* That would cause two variables named a in the same scope → conflict

Visual:

```
Global Scope:
    let a = 10
    var a = 20  // not allowed
```

---

# **14. Block vs Function Scope Comparison Table**

| Feature            | Block Scope | Function Scope |
| ------------------ | ----------- | -------------- |
| let/const          | Yes         | Yes            |
| var                | No          | Yes            |
| Nested visibility  | Allowed     | Allowed        |
| Outer access inner | No          | No             |
| TDZ applies        | Yes         | Yes            |

---

# **15. Real Execution Diagram (Text-Based)**

Code:

```javascript
let a = 10;

{
    let b = 20;
    {
        let b = 30;
        console.log(b);
    }
    console.log(b);
}
console.log(a);
```

Diagram:

```
Global:
  a = 10

Block-1:
  b = 20

Block-2:
  b = 30  (shadows b from Block-1)
```

Output:

```
30
20
10
```

---

# **16. Common Mistakes**

### Mistake 1: Expecting outer variable inside inner assignment

```javascript
let x = 10;

{
    let x = x + 5;  // TDZ error
}
```

x inside the block is in TDZ, so cannot use itself.

---

### Mistake 2: Declaring var inside blocks expecting block behavior

```javascript
if (true) {
    var name = "Priyesha";
}
console.log(name); // Priyesha (unexpected)
```

---

### Mistake 3: Accidentally shadowing variables

```javascript
let score = 50;

function update() {
    let score = 100; // shadowing
}
```

Shadowing is correct behavior, but beginners often assume this updates the global score.

---

### Mistake 4: Illegal shadowing

```javascript
const id = 101;

{
    var id = 202; // illegal
}
```

---

# **17. Summary Table for Block Scope and Shadowing**

| Concept             | Explanation                                  |
| ------------------- | -------------------------------------------- |
| Block Scope         | let/const exist only inside `{ }`            |
| var                 | Ignores block boundaries                     |
| Lexical Environment | Internal structure storing variables         |
| Scope Chain         | Inner scopes can access outer variables      |
| Shadowing           | Inner variable overrides outer in that scope |
| Illegal Shadowing   | Occurs when var tries to override let/const  |

---

# **18. Practice Exercises**

### **Exercise 1**

Identify which variable is shadowing and explain:

```javascript
let a = 5;
{
    let a = 10;
    {
        let a = 15;
        console.log(a);
    }
}
```

---

### **Exercise 2**

Is this legal or illegal?

```javascript
let city = "Ahmedabad";

{
    var city = "Surat";
}
```

Explain why.

---

### **Exercise 3**

Predict output:

```javascript
const batch = "BTECH-AI";

{
    let batch = "BTECH-CSE";
    console.log(batch);
}
console.log(batch);
```

---

### **Exercise 4**

Rewrite the code to avoid illegal shadowing:

```javascript
let x = 10;

{
    var x = 20;
}
```

---

### **Exercise 5**

Explain variable lookup sequence for this:

```javascript
let a = 10;

{
    let b = 20;

    {
        console.log(a + b);
    }
}
```

---

# **19. Multiple Choice Questions (MCQs)**

### Q1. Which keyword is block scoped?

1. var
2. let
3. const
4. Both let and const

**Answer: 4**

---

### Q2. Illegal shadowing occurs when:

1. let shadows let
2. const shadows const
3. let shadows var
4. var shadows let

**Answer: 4**

---

### Q3. Which is true?

1. Inner scope can access outer variables
2. Outer scope can access inner variables
3. var respects block scope
4. let does not respect block scope

**Answer: 1**

---

### Q4. Lexical Environment contains:

1. Only functions
2. Only variables
3. Variables + reference to parent scope
4. None of the above

**Answer: 3**

---

### Q5. What is shadowing?

1. When variables become undefined
2. When inner variable reassigns outer variable
3. When inner variable hides outer variable within its scope
4. When variable is unused

**Answer: 3**

---

