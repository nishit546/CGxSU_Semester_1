# **let and const in Loops and Closures**

Loops and closures are two areas where ES6 fundamentally changed how JavaScript behaves.
Before ES6, developers struggled because:

* `var` leaked outside loops
* closures inside loops captured the *same* variable
* asynchronous callbacks inside loops behaved unpredictably

---

# **1. Let and Const Inside Loops — Why They Are Different**

Before ES6, all developers used:

```javascript
for (var i = 0; i < 5; i++) { ... }
```

But:

* var has **function scope**
* var **ignores block scope**
* var creates **one shared variable i** for the entire loop

This causes many bugs, especially when:

* using closures
* using setTimeout
* using event listeners inside loops

ES6 fixed these issues by giving each iteration its **own separate i**.

---

# **2. var Inside Loops → Leaks Outside**

Example:

```javascript
for (var i = 1; i <= 3; i++) {
    console.log("Inside loop:", i);
}

console.log("Outside loop:", i);
```

Output:

```
Inside loop: 1
Inside loop: 2
Inside loop: 3
Outside loop: 4   (var leaked!)
```

### Why?

* var is NOT block-scoped
* i becomes part of the surrounding function/global scope

---

# **3. let Inside Loops → Private Per Iteration**

```javascript
for (let i = 1; i <= 3; i++) {
    console.log("Inside:", i);
}

console.log(i); // Error: i is not defined
```

### Why?

* let is **block-scoped**
* Each iteration of the loop gets a **new Lexical Environment**
* i does NOT leak outside the loop

---

# **4. Why ES6 Creates a New i for Every Iteration**

This is extremely important.

When we write:

```javascript
for (let i = 0; i < 3; i++) {
    console.log(i);
}
```

JavaScript internally creates:

```
Iteration 0 → i = 0 stored in a new block Lexical Environment
Iteration 1 → i = 1 stored in a new Lexical Environment
Iteration 2 → i = 2 stored in a new Lexical Environment
```

Each block:

```
{
    let i = iteration_value;
}
```

This is why closures inside loops work properly.

---

# **5. Closures With Loops — Why var Causes Bugs**

Example:

```javascript
for (var i = 1; i <= 3; i++) {
    setTimeout(() => console.log(i), 1000);
}
```

Expected:
1
2
3

Actual Output:

```
4
4
4
```

### WHY?

Because:

* var creates ONE shared i
* the loop finishes before setTimeout runs
* i becomes 4
* all closures point to the SAME shared i

Diagram:

```
One var i → shared by all iterations → final value 4
All setTimeout callbacks reference the same i
```

---

# **6. Closures With let — Correct Behavior**

```javascript
for (let i = 1; i <= 3; i++) {
    setTimeout(() => console.log(i), 1000);
}
```

Output:

```
1
2
3
```

### Why?

Because:

* Each iteration has its **own i**
* Closure captures the **i of that specific iteration**

Diagram:

```
Iteration 1 → i = 1 → callback prints 1
Iteration 2 → i = 2 → callback prints 2
Iteration 3 → i = 3 → callback prints 3
```

---

# **7. Behind the Scenes — Iteration Lexical Environments (Very Important)**

Consider:

```javascript
for (let i = 0; i < 3; i++) { ... }
```

JavaScript creates:

```
Iteration #0 → LexicalEnv0 → i = 0
Iteration #1 → LexicalEnv1 → i = 1
Iteration #2 → LexicalEnv2 → i = 2
```

Closures store the **reference to the Lexical Environment**, not the variable itself.

This ES6 behavior is the reason `let` solves the closure problem.

---

# **8. const Inside Loops**

You can use const inside loops when the variable inside each iteration never changes.

Example:

```javascript
for (const student of ["Jenil", "Arjun", "Yashvi"]) {
    console.log(student);
}
```

Output:

```
Jenil
Arjun
Yashvi
```

### Why does const work?

Because:

* const binding cannot change
* but **each iteration gets a fresh const student**

Bad example:

```javascript
for (const i = 0; i < 3; i++) { } // ERROR
```

Because `i++` tries to modify const.

---

# **9. let vs const in loops — When to use what**

### Use let when:

* variable needs to increment
* variable changes per iteration

Example: i in a for loop

### Use const when:

* using for..of / for..in
* iterating values where variable itself does not change

Example:

```javascript
for (const course of ["HTML", "CSS", "JS"]) {
    console.log(course);
}
```

---

# **10. Closures in Loops Examples**

### Example 1: Creating interview slots

Wrong (var):

```javascript
for (var slot = 1; slot <= 3; slot++) {
    setTimeout(() => {
        console.log("Interview slot:", slot);
    }, 1000);
}
```

Output:

```
Interview slot: 4
Interview slot: 4
Interview slot: 4
```

Right (let):

```javascript
for (let slot = 1; slot <= 3; slot++) {
    setTimeout(() => {
        console.log("Interview slot:", slot);
    }, 1000);
}
```

Output:

```
Interview slot: 1
Interview slot: 2
Interview slot: 3
```

---

# **11. Closures With Event Listeners in Loops**

Example: attaching listeners to 3 buttons.

Wrong:

```javascript
for (var i = 1; i <= 3; i++) {
    document.getElementById("btn" + i)
        .addEventListener("click", () => {
            console.log("Button clicked:", i);
        });
}
```

ALL buttons print:

```
Button clicked: 4
```

Correct:

```javascript
for (let i = 1; i <= 3; i++) {
    document.getElementById("btn" + i)
        .addEventListener("click", () => {
            console.log("Button clicked:", i);
        });
}
```

---


# **12. Rare Case — Shadowing and Loops**

Shadowing inside loops:

```javascript
let x = 10;

for (let x = 1; x <= 3; x++) {
    console.log("Inner x:", x);
}

console.log("Outer x:", x);
```

Output:

```
Inner x: 1
Inner x: 2
Inner x: 3
Outer x: 10
```

---

# **13. Common Mistakes**

### Mistake 1: Using var out of habit

```javascript
for (var i = 0; i < 5; i++) {}
console.log(i); // leaks
```

### Mistake 2: Not understanding shared closure problem

### Mistake 3: Using let incorrectly inside const loops

```javascript
for (const x of arr) {
    x++; // changing const → error
}
```

### Mistake 4: Reusing let from outer scope

```javascript
let i = 5;
for (let i = 0; i < 3; i++) {
    console.log(i);
}
console.log(i); // 5 (shadowing confusion)
```

---

# **14. Summary Table**

| Feature                   | var | let | const |
| ------------------------- | --- | --- | ----- |
| Block Scope               | No  | Yes | Yes   |
| Function Scope            | Yes | Yes | Yes   |
| Per-iteration environment | No  | Yes | Yes   |
| Good for counters         | No  | Yes | No    |
| Works in for-of           | Yes | Yes | Yes   |
| Modifiable                | Yes | Yes | No    |

---

# **15. Practice Exercises**

### **Exercise 1**

Fix the closure bug:

```javascript
for (var i = 1; i <= 3; i++) {
    setTimeout(() => console.log(i), 1000);
}
```

---

### **Exercise 2**

Predict output:

```javascript
let i = 100;

for (let i = 1; i <= 3; i++) {
    console.log(i);
}

console.log(i);
```

---

### **Exercise 3**

Explain why this is wrong:

```javascript
for (const i = 0; i < 5; i++) {
    console.log(i);
}
```

---

### **Exercise 4**

Write a loop that prints:

```
Student 1: Jenil
Student 2: Arjun
Student 3: Krishna
```

Use let and a closure.

---

### **Exercise 5**

Attach 5 event listeners using a loop so each prints its own index.

---

# **16. Multiple Choice Questions (MCQs)**

### Q1. let inside loops creates:

1. One shared variable
2. A new binding per iteration
3. A global variable
4. A function-scoped variable

**Answer: 2**

---

### Q2. var inside loops is:

1. Block scoped
2. Function scoped
3. Loop scoped
4. Iteration scoped

**Answer: 2**

---

### Q3. Which keyword solves closure issues in loops?

1. var
2. let
3. function
4. return

**Answer: 2**

---

### Q4. const inside for-of creates:

1. One const reused
2. A new const per iteration
3. A SyntaxError always
4. A var equivalent

**Answer: 2**

---

### Q5. Why does this fail?

```javascript
for (const i = 0; i < 3; i++) {}
```

1. Cannot increment a const
2. Cannot declare inside loop
3. const is global
4. let must be used

**Answer: 1**

---

# **17. Mini Assignment — CodingGita "Attendance Logger" using let + closures**

Create a loop over:

```javascript
let students = ["Jenil", "Arjun", "Yashvi", "Priyesha", "Krishna"];
```

Your tasks:

1. Create 5 “Attendance buttons” (btn1, btn2, …)
2. For each iteration, attach an event listener
3. Using let, each button prints its own student name
4. Add a delay of 1 sec (setTimeout) and print:

```
Marking attendance for: <student>
```

You must use closures and ensure no incorrect values print.

---
