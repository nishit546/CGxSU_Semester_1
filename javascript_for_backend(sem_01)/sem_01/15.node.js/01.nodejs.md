# What is Node.js?

## Runtime, Execution Model, and How It Really Works

---

## 1. Why Node.js Exists

JavaScript was originally designed to run **inside browsers**.
Its responsibilities were limited to:

* Handling user interactions
* Updating the DOM
* Making network requests

As web applications evolved, there was a strong need to:

* Use **one language** for both frontend and backend
* Handle **thousands of concurrent users**
* Build **fast, scalable network servers**

Traditional backend systems often followed a **thread-per-request model**, which:

* Consumes more memory
* Does not scale efficiently for I/O-heavy workloads

Node.js was created specifically to address these limitations.

---

## 2. What Exactly is Node.js?

**Node.js is a JavaScript runtime environment that allows JavaScript to run outside the browser**, primarily on servers.

Key characteristics:

* Built on **Google’s V8 JavaScript engine**
* Uses **event-driven, non-blocking I/O**
* Designed for **network applications and APIs**
* Executes JavaScript on the server

Node.js is **not a framework**.
It is a **runtime plus core APIs**.

---

## 3. Node.js vs Browser JavaScript

Although both environments run JavaScript, their capabilities are very different.

### Browser JavaScript

* Access to DOM and BOM
* Uses `window` as the global object
* Sandboxed for security
* Limited access to system resources

### Node.js JavaScript

* No DOM or `window`
* Uses `global` as the global object
* Full access to:

  * File system
  * Network
  * OS-level features

This distinction is critical before writing backend code.

---

## 4. Single-Threaded Does Not Mean Slow

One of the most misunderstood statements about Node.js is:

> “Node.js is single-threaded.”

This is **partially true** and often misunderstood.

### What it actually means:

* JavaScript code runs on **one main thread**
* Node.js does **not** create a new thread per request

But this alone does **not** explain Node’s performance.

---

## 5. Node.js Execution Model (High-Level View)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AtxgFPN5LaUZvPOXelJlSuA.jpeg)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20200224050909/nodejs2.png)

Node.js follows an **event-driven architecture**.

At a high level:

* JavaScript executes on the **main thread**
* Long-running or I/O tasks do **not block execution**
* Completion of async tasks is handled via the **event loop**

This allows Node.js to handle many concurrent operations efficiently.

---

## 6. The Role of libuv and the Worker Pool

![Image](https://miro.medium.com/0%2AtKlj2lrXFPOPSXQr)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1134/1%2Ax4oDHcANrYG1_V8oDjhZCQ.png)

Under the hood, Node.js uses **libuv**, a C library that provides:

* The event loop
* A **worker thread pool**
* Asynchronous I/O handling

### How work is divided:

* **Main thread**

  * Executes JavaScript
  * Handles callbacks and promises
* **Worker pool**

  * Executes heavy or blocking operations

### Tasks handled by the worker pool:

* File system operations (`fs`)
* DNS lookups
* Cryptographic operations
* Compression

Once a task completes, its callback is pushed back into the **event loop**, ready for execution.

---

## 7. Why Non-Blocking I/O Matters

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220208175332/resizedimagePromo2-660x371.jpeg)

![Image](https://miro.medium.com/1%2Ay8OTPaojQ9uRkxZK0Adc3Q.png)

In Node.js:

* I/O operations are **non-blocking**
* The main thread remains free to handle other requests
* The server stays responsive even under load

If blocking code runs on the main thread:

* The event loop stops
* All incoming requests wait
* The server appears frozen

This is why **asynchronous programming is mandatory** in Node.js.

---

## 8. Connecting This Back to JavaScript Async

Everything you learned earlier now fits together:

* Callbacks, promises, and async/await
* Event loop and task queues
* Microtasks and macrotasks

Node.js **depends on these concepts** to work efficiently.

Without a solid async foundation:

* Node.js feels confusing
* Performance issues are hard to debug

With async clarity:

* Node.js becomes predictable and powerful

---

## 9. Key Takeaways

* Node.js allows JavaScript to run on the server
* JavaScript execution is single-threaded
* Heavy tasks run in the **libuv worker pool**
* Non-blocking I/O is the core design principle
* Async JavaScript knowledge is essential

This mental model will be used **repeatedly** in the upcoming articles.

---

