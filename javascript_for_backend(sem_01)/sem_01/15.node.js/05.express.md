# Introduction to Express.js

## From Raw HTTP to Clean, Scalable APIs

## 1. Why Express.js Exists

In the previous articles, you learned how to:

* Create servers using the `http` module
* Handle `req` and `res` manually
* Design RESTful APIs using correct HTTP methods

While this is powerful, it quickly becomes **verbose and hard to maintain** as applications grow.

Problems with plain HTTP:

* Manual routing using `if` / `else`
* Repeated header and status code handling
* Manual request body parsing
* Difficult code organization

**Express.js exists to solve these problems without changing the fundamentals.**

---

## 2. What is Express.js?

Express.js is a **minimal, unopinionated web framework** built on top of Node.js.

Key points:

* Built on top of the Node.js `http` module
* Does **not change how HTTP works**
* Simplifies routing, request handling, and responses
* Adds a clean middleware system

Important clarification:

> Express does not replace Node.js
> Express **uses** Node.js

---

## 3. Express vs HTTP Module (Conceptual Comparison)

| Aspect           | HTTP Module    | Express.js           |
| ---------------- | -------------- | -------------------- |
| Server creation  | Manual         | Simplified           |
| Routing          | `if / else`    | Clean route methods  |
| Request body     | Manual parsing | Built-in middleware  |
| Response helpers | Basic          | JSON, status helpers |
| Code structure   | Flat           | Modular              |

Express improves **developer experience**, not protocol behavior.

---

## 4. Creating a Basic Express Server

```js
const express = require("express");

const app = express();

app.get("/", (req, res) => {
  res.send("Express server is running");
});

app.listen(3000, () => {
  console.log("Server started on port 3000");
});
```

Compare this with the raw HTTP server:

* No manual headers
* No `res.end()`
* Cleaner syntax

Under the hood, Express still uses:

* The same request–response cycle
* The same event loop
* The same libuv worker pool

---

## 5. Express Request–Response Lifecycle

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20250705152348042640/Request-and-Response-Cycle.webp)

![Image](https://miro.medium.com/1%2AkMNzu4zx40QvwQUWa9dCOw.png)

When a request hits an Express server:

1. Request enters the Express app
2. Middleware functions execute (if any)
3. Matching route handler is called
4. Response is sent back to the client

This layered flow is what makes Express powerful and extensible.

---

## 6. Express `req` and `res` Objects

Express wraps the original Node.js objects and **adds convenience methods**.

### Request (`req`)

Still contains:

* Method
* URL
* Headers
* Body

But with helpers:

* `req.params`
* `req.query`
* `req.body` (via middleware)

---

### Response (`res`)

Adds useful methods:

* `res.send()`
* `res.json()`
* `res.status()`

Example:

```js
res.status(200).json({ message: "Success" });
```

This reduces boilerplate and improves readability.

---

## 7. Built-in Middleware in Express

![Image](https://developer.okta.com/assets-jekyll/blog/express-middleware-examples/middleware-30b3b30ad54e21d8281719042860f3edd9fb1f40f93150233a08165d908f4631.png)

![Image](https://cdn.hashnode.com/res/hashnode/image/upload/v1669745982483/k3wiCbsHY.png)

Middleware are functions that:

* Run before route handlers
* Can read or modify `req` and `res`
* Decide whether to continue the request

Example:

```js
app.use(express.json());
```

This single line replaces **manual request body parsing** you did earlier with HTTP.

---

## 8. How Express Still Uses Async Internals

Even with Express:

* JavaScript runs on a single thread
* I/O is non-blocking
* Heavy tasks go to the libuv worker pool

Express does **not**:

* Make code multi-threaded
* Eliminate blocking issues

Bad async code in Express still freezes the server.

---

## 9. What Express Does NOT Do

Important boundaries:

* Does not define REST principles
* Does not handle databases by default
* Does not provide authentication automatically
* Does not manage performance magically

Express is a **tool**, not a solution to every backend problem.

---

## 10. When to Use Express

Express is ideal when:

* You are building REST APIs
* You need clean routing
* You want middleware support
* You want scalable backend structure

It is not required for:

* Very small scripts
* One-off utilities
* Simple file processing tasks

---

## 11. Key Takeaways

* Express is built on Node’s HTTP module
* It simplifies routing and responses
* It keeps REST principles intact
* Middleware is the core abstraction
* Async rules still apply
* Express improves structure, not fundamentals

---

