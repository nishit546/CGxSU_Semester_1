# Understanding RESTful APIs

## Designing APIs Using Plain HTTP 

## 1. Why REST Matters in Backend Development

Once a server can handle requests and send responses, the next question is:

> **How should APIs be designed so that clients can use them consistently and predictably?**

This is where **REST** comes in.

REST is **not a library**, **not a framework**, and **not tied to Node.js**.
It is a **set of architectural principles** used to design networked APIs.

Understanding REST before Express ensures that:

* API design is not framework-dependent
* Endpoints are clean and predictable
* Backend logic scales well over time

---

## 2. What is REST?

**REST** stands for **Representational State Transfer**.

In simple terms:

* The server exposes **resources**
* Clients interact with those resources using **HTTP methods**
* Each request contains all the information needed to process it

REST is built **on top of HTTP**, not separate from it.

---

## 3. Resources: The Core Concept of REST

![Image](https://kajabi-storefronts-production.kajabi-cdn.com/kajabi-storefronts-production/file-uploads/blogs/2147485434/images/315487-7af3-d17-c8af-0b4d8af188db_rest-api-model-diagram.png)

![Image](https://restfulapi.net/wp-content/uploads/How-to-Design-a-REST-API.png)

In REST, everything revolves around **resources**.

A resource is:

* A logical entity
* Represented using a URL
* Usually a noun, not a verb

Examples:

* `/users`
* `/users/101`
* `/products`
* `/orders/55`

Bad example:

* `/getUsers`
* `/createUser`

Good REST design avoids actions in URLs.

---

## 4. HTTP Methods and Their Meaning in REST

![Image](https://www.techtarget.com/rms/onlineimages/http_methods_purpose_and_properties-f_mobile.png)

![Image](https://media.licdn.com/dms/image/v2/D4D12AQHxG4Prn4ZrBQ/article-cover_image-shrink_600_2000/article-cover_image-shrink_600_2000/0/1718998421506?e=2147483647\&t=-2LQBR1-lDFdKqTy66DNfGm4cTz7xy27k8-QYYsYaio\&v=beta)


HTTP methods define **what action the client wants to perform on a resource**.
In REST, **the same URL behaves differently based on the HTTP method**.

The URL represents **the resource**
The HTTP method represents **the action**

This separation is the foundation of RESTful design.

---

## 4.1 GET – Retrieve Data (Read-Only)

### Purpose

Fetch data from the server **without modifying anything**.

### Characteristics

* Safe (does not change server state)
* Idempotent (same request → same result)
* Request body is **not used**
* Can be cached by browsers and proxies

### Common Use Cases

* Fetch list of resources
* Fetch a single resource
* Fetch filtered data

### Examples

```http
GET /users
GET /users/101
GET /products?category=electronics
```

### Plain HTTP Example

```js
if (req.method === "GET" && req.url === "/users") {
  res.writeHead(200, { "Content-Type": "application/json" });
  res.end(JSON.stringify([{ id: 1, name: "Arjun" }]));
}
```

### Important Rule

Never use GET to:

* Create data
* Update data
* Delete data

Doing so breaks REST semantics and causes security issues.

---

## 4.2 POST – Create a New Resource

### Purpose

Create a **new resource** on the server.

### Characteristics

* Not idempotent
* Uses request body
* Server decides resource ID
* Commonly returns `201 Created`

### Common Use Cases

* Create a new user
* Place an order
* Submit a form

### Examples

```http
POST /users
POST /orders
```

### Plain HTTP Example

```js
if (req.method === "POST" && req.url === "/users") {
  let body = "";

  req.on("data", chunk => body += chunk);
  req.on("end", () => {
    const user = JSON.parse(body);

    res.writeHead(201, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ message: "User created", user }));
  });
}
```

### When NOT to use POST

* For updates → use PUT or PATCH
* For fetching data → use GET

---

## 4.3 PUT – Replace an Entire Resource

### Purpose

Replace the **entire representation** of a resource.

### Characteristics

* Idempotent
* Requires full object
* Missing fields may be overwritten or removed
* Client specifies resource ID

### Common Use Cases

* Replace user profile
* Replace product details

### Examples

```http
PUT /users/101
```

### Example Scenario

Client sends **complete object**:

```json
{
  "name": "Aditya",
  "email": "aditya@example.com",
  "role": "student"
}
```

### Plain HTTP Example

```js
if (req.method === "PUT" && req.url === "/users/101") {
  res.writeHead(200);
  res.end("User replaced");
}
```

### Important Warning

If you only want to update **one field**, PUT is usually **not the best choice**.

---

## 4.4 PATCH – Update Part of a Resource

### Purpose

Update **specific fields** of a resource.

### Characteristics

* Not always idempotent
* Partial updates
* Safer than PUT for small changes

### Common Use Cases

* Update user email
* Change account status
* Toggle flags

### Examples

```http
PATCH /users/101
```

### Example Payload

```json
{
  "email": "newemail@example.com"
}
```

### Plain HTTP Example

```js
if (req.method === "PATCH" && req.url === "/users/101") {
  res.writeHead(200);
  res.end("User updated partially");
}
```

### PUT vs PATCH (Important Distinction)

* PUT → full replacement
* PATCH → partial modification

---

## 4.5 DELETE – Remove a Resource

### Purpose

Delete a resource from the server.

### Characteristics

* Idempotent
* No request body required
* Response body often empty

### Common Use Cases

* Delete a user
* Cancel an order

### Examples

```http
DELETE /users/101
```

### Plain HTTP Example

```js
if (req.method === "DELETE" && req.url === "/users/101") {
  res.writeHead(204);
  res.end();
}
```

### Recommended Status Codes

* `200` – Deleted with response
* `204` – Deleted with no content

---

## 4.6 HEAD – Metadata Without the Body

### Purpose

Retrieve **headers only**, without response body.

### Characteristics

* Same as GET, but no body
* Used for checks and validation
* Lightweight

### Common Use Cases

* Check if resource exists
* Validate content length
* Cache validation

### Example

```http
HEAD /users/101
```

### Practical Insight

Browsers and CDNs often use HEAD internally for optimization.

---

## 4.7 OPTIONS – Discover Supported Operations

### Purpose

Tell the client **what HTTP methods are allowed** on a resource.

### Common Use Cases

* CORS preflight requests
* API introspection

### Example

```http
OPTIONS /users
```

### Response Headers Example

```http
Allow: GET, POST, PUT, PATCH, DELETE
```

This method is critical for **browser-based APIs**.

---

## 4.8 Summary Table (Quick Reference)

| Method  | Purpose            | Idempotent | Body |
| ------- | ------------------ | ---------- | ---- |
| GET     | Read data          | Yes        | No   |
| POST    | Create resource    | No         | Yes  |
| PUT     | Replace resource   | Yes        | Yes  |
| PATCH   | Partial update     | No         | Yes  |
| DELETE  | Remove resource    | Yes        | No   |
| HEAD    | Metadata only      | Yes        | No   |
| OPTIONS | Allowed operations | Yes        | No   |

---

## 4.9 Why Correct Method Usage Matters

Using the wrong HTTP method:

* Breaks REST semantics
* Causes security vulnerabilities
* Confuses frontend and API consumers
* Makes APIs harder to scale

Correct usage:

* Makes APIs predictable
* Improves caching
* Simplifies debugging
* Aligns with industry standards

---

## 4.10 TRACE and CONNECT (Rare but Important HTTP Methods)

Some HTTP methods exist for **diagnostic and networking purposes** and are **not used in REST API design**, but it is important to understand what they do.

---

### TRACE – Request Debugging

The `TRACE` method is used to **diagnose how an HTTP request is processed** as it travels through proxies, gateways, or middleware.

What TRACE does:

* Sends a request to the server
* The server responds by **echoing the same request back**
* Helps identify header changes or request transformations

Important points:

* Used only for debugging
* Can expose sensitive headers
* Commonly **disabled in production** for security reasons
* Not used in RESTful APIs

---

### CONNECT – Secure Tunneling

The `CONNECT` method is used to **establish a network tunnel**, most commonly for **HTTPS communication through a proxy**.

What CONNECT does:

* Creates a direct TCP tunnel to a target server
* Allows encrypted data to pass through a proxy
* Used by browsers and proxies, not by application code

Important points:

* Works at network/proxy level
* Not involved in resource operations
* Not implemented in REST APIs

---

### Practical Note

For REST API development, you should focus on:

* `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`

`TRACE` and `CONNECT` are **good to know for completeness and security awareness**, but they are **not part of REST API implementation**.

---

## 5. Statelessness in REST

One of the most important REST principles is **statelessness**.

This means:

* The server does **not store client state**
* Every request is independent
* All required data is sent with the request

Example:

* Authentication tokens are sent with every request
* The server does not rely on previous requests

Why this matters:

* Easy horizontal scaling
* Fewer bugs
* Better fault tolerance

---

## 6. Status Codes Are Part of the API Contract

![Image](https://restfulapi.net/wp-content/uploads/HTTP-Error-Codes.jpg)

![Image](https://cdn.prod.website-files.com/62796ab9647626cbab663f42/671124657e500c1aa0737fe2_6711242c69ef42275511fbb9_API%2520response%2520code%2520categories%2520%284%29.webp)

Status codes tell the client **what happened**, even before reading the response body.

Common REST status codes:

* `200` – Request successful
* `201` – Resource created
* `400` – Invalid request
* `401` – Unauthorized
* `404` – Resource not found
* `500` – Server error

Clients rely heavily on these codes to handle responses correctly.

---

## 7. REST API Example Using Plain HTTP (GET)

```js
const http = require("http");

const server = http.createServer((req, res) => {
  if (req.method === "GET" && req.url === "/users") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(
      JSON.stringify([
        { id: 1, name: "Aditya" },
        { id: 2, name: "Priyesha" }
      ])
    );
  }
});

server.listen(3000);
```

Key REST points demonstrated:

* Resource-based URL (`/users`)
* Correct HTTP method (`GET`)
* Proper status code (`200`)
* JSON response format

---

## 8. REST API Example Using Plain HTTP (POST)

```js
const http = require("http");

const server = http.createServer((req, res) => {
  if (req.method === "POST" && req.url === "/users") {
    let body = "";

    req.on("data", chunk => {
      body += chunk.toString();
    });

    req.on("end", () => {
      const newUser = JSON.parse(body);

      res.writeHead(201, { "Content-Type": "application/json" });
      res.end(
        JSON.stringify({
          message: "User created",
          user: newUser
        })
      );
    });
  }
});

server.listen(3000);
```

This shows:

* POST used for creation
* Data sent in request body
* `201 Created` status code
* Stateless request handling

---

## 9. What REST Does NOT Define

REST does **not** specify:

* How authentication is implemented
* How data is stored
* Which programming language to use
* Which framework to use

REST only defines **how APIs should behave**, not how they are built internally.

---

## 10. Why Learn REST Before Express?

Learning REST at the HTTP level ensures:

* Express routes make sense
* API design stays clean
* Framework changes do not break fundamentals
* Interviews become easier

Express will:

* Simplify routing
* Add middleware
* Reduce boilerplate

But it will **not change REST principles**.

---

## 11. Key Takeaways

* REST is an architectural style, not a framework
* APIs are built around resources
* HTTP methods define actions
* Statelessness enables scalability
* Status codes are part of the API contract
* REST can be implemented using plain HTTP

---

