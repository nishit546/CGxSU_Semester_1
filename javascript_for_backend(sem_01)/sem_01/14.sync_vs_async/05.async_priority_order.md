# JavaScript Asynchronous Priority Order 

## 1. Asynchronous Priority Order 

This article defines the **exact execution priority** of all major asynchronous mechanisms in JavaScript.

It answers:

* Which async operations run first?
* Which ones wait?
* What belongs to the microtask queue?
* What belongs to the macrotask queue?

This article intentionally focuses on **ordering and classification**, not implementation details.

---

## 2. Absolute Priority Rule

> **Synchronous code always executes first.**

No asynchronous operation runs until the call stack is empty.

---

## 3. Global Execution Priority (High → Low)

### Overall Order

1. **Synchronous Code (Call Stack)**
2. **Microtask Queue**
3. **Macrotask Queue**

This order is strict and never violated.

---

## 4. Microtask Queue (High Priority)

### Characteristics

* Executes immediately after synchronous code
* Executes completely before any macrotask
* Can enqueue more microtasks
* Event loop does not proceed until empty

---

### Operations in Microtask Queue

The following async mechanisms are scheduled as **microtasks**:

1. **Promise Resolution Handlers**

   * `.then()`
   * `.catch()`
   * `.finally()`

2. **`async/await` (After `await`)**

   * Code after `await` is queued as a microtask

3. **`queueMicrotask()`**

4. **MutationObserver callbacks** (browser)

---

### Microtask Priority Summary

| Priority Level | Async Mechanism          |
| -------------- | ------------------------ |
| Highest        | Promise callbacks        |
| Highest        | async/await continuation |
| Highest        | queueMicrotask           |

All microtasks share the **same priority level**.

---

## 5. Macrotask Queue (Lower Priority)

### Characteristics

* Executes after microtasks
* One macrotask per event loop cycle
* Timers are not guaranteed to run exactly on time

---

### Operations in Macrotask Queue

The following async mechanisms are scheduled as **macrotasks**:

1. **Timers**

   * `setTimeout`
   * `setInterval`

2. **`setImmediate`** (Node.js)

3. **I/O Callbacks**

   * File system
   * Network requests

4. **Event Handlers**

   * DOM events (browser)

---

### Macrotask Priority Summary

| Priority Level | Async Mechanism        |
| -------------- | ---------------------- |
| Lower          | setImmediate (Node.js) |
| Lower          | setTimeout             |
| Lower          | setInterval            |
| Lowest         | I/O callbacks          |

(All macrotasks are lower than microtasks)

---

## 6. Relative Priority Inside Macrotasks (Node.js)

Within macrotasks, Node.js follows **event loop phases**:

1. Timers (`setTimeout`, `setInterval`)
2. I/O callbacks
3. Poll phase
4. Check phase (`setImmediate`)
5. Close callbacks

This explains why `setImmediate` may run before `setTimeout(0)` after I/O.

---

## 7. Priority Comparison Example

```js
console.log("Start");

setTimeout(() => console.log("setTimeout"), 0);

queueMicrotask(() => console.log("Microtask"));

console.log("End");
```

**Output**

```
Start
End
Microtask
setTimeout
```

---

## 8. Priority Cheatsheet (One Look)

### Highest → Lowest Priority

1. Synchronous code
2. Microtasks

   * Promise callbacks
   * async/await continuation
   * queueMicrotask
3. Macrotasks

   * setImmediate
   * setTimeout
   * setInterval
   * I/O callbacks

---

## 9. Key Rules to Remember

* Microtasks always beat timers
* All microtasks complete before any macrotask
* Timers do not interrupt execution
* Delays define *earliest execution*, not priority
* Event loop behavior is deterministic

---

## 10. Summary

* JavaScript uses strict priority queues
* Microtasks have higher priority than macrotasks
* Timers are macrotasks
* async/await is built on microtasks
* Understanding priority prevents async bugs

---
