# **3: Queue**

## From Stack to Queue (The Missing Piece)

In the previous article, you learned one critical fact:

> **Async code does not stay on the stack.**

So the obvious next question is:

> If async code doesn’t execute immediately, **where does it go?**

The answer is simple and familiar:

**It waits in a Queue.**

---

## What Is a Queue (In the Simplest Way)

A queue is again **just an array**, but with a **different rule**.

* Add items at one end
* Remove items from the **other end**

This rule is called **FIFO**:

> **First In, First Out**

---

## Visualizing a Queue Using an Array

![Image](https://miro.medium.com/v2/resize%3Afit%3A1200/1%2AGuV58J8SJ-gmjfz7aaOFjA.png?utm_source=codinggita.com)

![Image](https://data-flair.training/blogs/wp-content/uploads/sites/2/2019/06/Insertion-in-C-queue.jpg?utm_source=codinggita.com)

Think of a real-life waiting line:

* First person in line → served first
* New people join at the back

This is exactly how async JavaScript works.

---

## Queue Operations (Using Array Methods)

### Enqueue — Add to the queue

```js
queue.push("Task A");
```

### Dequeue — Remove from the front

```js
queue.shift();
```

Same array.
Different rule.
Different behavior.

---

## Why JavaScript Needs a Queue

Remember:

* JavaScript has **one stack**
* Only one thing can run at a time

So when async work finishes (timer, network, event), JavaScript needs a place to **hold callbacks until the stack is free**.

That place is the **queue**.

---

## setTimeout and the Queue

Let’s look at a familiar example:

```js
console.log("Start");

setTimeout(() => {
  console.log("Timer done");
}, 1000);

console.log("End");
```

### Execution Flow

1. `"Start"` → stack → executed
2. `setTimeout` → stack → registers timer → exits
3. `"End"` → stack → executed
4. Timer finishes → callback goes to **queue**
5. Stack becomes empty
6. Callback moves from queue → stack

---

## Visualizing This Flow

![Image](https://www.javascripttutorial.net/wp-content/uploads/2020/01/javascript-setTimeout-step-1.png?utm_source=codinggita.com)

![Image](https://media2.dev.to/dynamic/image/width%3D1600%2Cheight%3D900%2Cfit%3Dcover%2Cgravity%3Dauto%2Cformat%3Dauto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Flqhhnr6n1w1l13g75ki0.png?utm_source=codinggita.com)

This explains why output is:

```
Start
End
Timer done
```

---

## Important Rule (Students Must Remember This)

> **The queue does nothing by itself.**

Tasks don’t jump onto the stack.

Something else controls this movement…

That “something” is coming next.

---

## Queue and Browser Events

Queues don’t only hold timers.

They also hold:

* Button click handlers
* Keyboard events
* Mouse events
* Network callbacks

Example:

```js
button.addEventListener("click", () => {
  console.log("Clicked");
});
```

The click handler:

* Is **registered**
* Waits in the queue
* Runs only when the stack is empty

---

## Why Async Feels Delayed Sometimes

Even if async work finishes quickly:

* If the stack is busy
* The queue keeps waiting

This explains bugs like:

* Delayed UI updates
* Timers firing “late”
* Slow response under heavy computation

---

## The Big Performance Problem with Arrays

Here’s an important insight:

```js
queue.shift();
```

This operation:

* Removes the first element
* Shifts all remaining elements
* Can be **slow** for large queues

![Image](https://i.sstatic.net/K79Lu.png?utm_source=codinggita.com)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/DeleteArray.png?utm_source=codinggita.com)

This leads to a natural question:

> If queues are so important, is using arrays always efficient?

The answer is **no**.

And that leads us directly to the next article.

---

## Key Mental Model (Lock This In)

Say this clearly:

> Stack = execution
> Queue = waiting

Async JavaScript is simply **waiting + scheduling**, not parallel execution.

---

## Quick Recap

* Queue follows FIFO
* Async callbacks wait in a queue
* Queue uses arrays conceptually
* Timers, events, network callbacks all use queues
* Queue waits for the stack to become empty

---
