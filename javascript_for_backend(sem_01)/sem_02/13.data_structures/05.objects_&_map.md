# **5: Objects & Maps — How JavaScript Remembers Async State**

## Why Order Is Not Enough Anymore

So far, we’ve learned:

* Arrays → order
* Stack → execution
* Queue → waiting
* Linked List → performance

But async JavaScript has another big problem to solve:

> **How do we remember things when execution pauses?**

Examples:

* Which promise belongs to which API call?
* Which callback belongs to which event?
* Which async task is completed and which is still pending?

For this, **order is not enough**.

JavaScript now needs **lookup**.

---

## Enter Objects (Key → Value Thinking)

An object in JavaScript is a **key–value store**.

```js
const user = {
  name: "Amit",
  role: "student"
};
```

Instead of position (`[0]`, `[1]`), we use **identity** (`name`, `role`).

This shift is critical for async systems.

---

## Visualizing Object Storage

![Image](https://www.freecodecamp.org/news/content/images/2021/07/Blue--Violet-and-Orange-Shapes-Fitness-Influencer-YouTube-Thumbnail-Set--3-.png?utm_source=codinggita.com)

![Image](https://media.geeksforgeeks.org/wp-content/uploads/20220208171353/keyvaluedatamodel.jpg?utm_source=codinggita.com)

Think of it like labeled boxes:

* You don’t care where the box is
* You care about the **label**

---

## Why Async JavaScript Needs Objects

Async operations are **not sequential**.

Multiple things may be:

* In progress
* Completed
* Failed

JavaScript needs to track them **individually**.

Example (conceptual):

```js
pendingRequests = {
  "req_101": callback1,
  "req_102": callback2
};
```

When a response comes back:

* JS looks up the callback by key
* Executes the correct one

No scanning.
No guessing.
Just lookup.

---

## Objects Are Everywhere in Async Internals

JavaScript engines use object-like structures to track:

* Promise state (`pending`, `fulfilled`, `rejected`)
* Event listeners by type
* Async task metadata
* Closure variables

This is why async systems scale.

---

## The Problem with Objects (Small but Important)

Objects work well, but they have limits:

* Keys are mostly strings
* Ordering is not guaranteed for logic
* Not ideal for all use cases

So JavaScript provides a better tool.

---

## Map — A Better Object for Async Use Cases

`Map` is designed specifically for **key–value storage**.

```js
const taskMap = new Map();

taskMap.set(requestId, callback);
taskMap.get(requestId);
```

Differences that matter:

* Keys can be anything (objects, functions)
* Clear intent: lookup storage
* Predictable behavior

---

## Visualizing Map Usage

![Image](https://cubedev-blog-images.s3.us-east-2.amazonaws.com/293dae27-10b5-4e79-b740-46fe6d23a256.gif?utm_source=codinggita.com)

![Image](https://substackcdn.com/image/fetch/%24s_%21CV5A%21%2Cf_auto%2Cq_auto%3Agood%2Cfl_progressive%3Asteep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F54a2cfd0-417b-4279-aff5-b165179b7115_1746x966.png?utm_source=codinggita.com)

You can think of `Map` as a **professional version of an object** for async coordination.

---

## How Promises Use Object-Like Storage (Conceptual)

A promise internally needs to remember:

* Current state
* Result or error
* Registered callbacks

Conceptually:

```js
promise = {
  state: "pending",
  value: undefined,
  handlers: [fn1, fn2]
};
```

Here:

* `state` → object property
* `handlers` → array
* All stored together in memory

Promises work because **objects remember state even when execution pauses**.

---

## Async Example That Depends on Lookup

```js
function fetchData(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("Data for " + id);
    }, 1000);
  });
}
```

Behind the scenes:

* Each promise has its own stored state
* When timer finishes, JS looks up the correct promise
* Resolves only that one

Without objects/maps, this would be impossible.

---

## Key Mental Shift 

> Arrays help JavaScript **schedule work**
> Objects and Maps help JavaScript **remember work**

Both are required for async behavior.

---

## Where Objects & Maps Fit in the Big Picture

```
Array       → Order
Stack       → Execution
Queue       → Waiting
Linked List → Performance
Object/Map  → Memory & Identity
```

Async JS breaks if **any one of these is missing**.

---

## Quick Recap

* Objects store data by identity, not position
* Async systems need lookup, not order
* Objects track state
* Maps improve async coordination
* Promises depend heavily on object-like storage

---

