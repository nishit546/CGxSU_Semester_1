# 05.3: Type Modifiers in C

**`short`, `long`, `long long`, `signed`, `unsigned`**

C lets you *tune* an integer type for **range** and **storage**. That‚Äôs what modifiers do.
Think of it like choosing the right container for data:

* A coffee cup (`short`) for small amounts
* A bottle (`int`) for regular amounts
* A gallon jug (`long long`) for huge amounts
* ‚ÄúNo negatives allowed‚Äù (`unsigned`) when values can‚Äôt be below zero

---

## 1) Why modifiers exist

* To **fit the data** (followers, views, money, timestamps) without wasting memory.
* To **avoid overflow** when numbers get large.
* To **express intent**: ‚Äúthis count can‚Äôt be negative‚Äù ‚Üí `unsigned`.

---

## 2) The five modifiers in practice

### `short`

* Typically **2 bytes** (on most modern systems).
* Use when the **range is small** (e.g., age, small counters).

```c
short int age = 19;        // often 2 bytes
unsigned short likes = 512; // 0..65535 (typical)
```

A smaller integer type. Good for memory-saving when values are small (like classroom strength).

```c
#include <stdio.h>
int main() {
    short s = 32767;   // maximum value for short
    printf("short = %hd\n", s);

    s = 32768;   // exceeding the limit
    printf("short after overflow = %hd\n", s);

    return 0;
}
```

**Output (on most systems):**

```
short = 32767
short after overflow = -32768
```

üí° Explanation: `short` usually uses **2 bytes** ‚Üí range: `-32768 to 32767`.
When you go beyond the limit, it **wraps around** (overflow).


### `long`

* Size varies by platform (32- or 64-bit).
* ‚ÄúBigger than `int`‚Äù (or equal, depending on platform).

```c
long int balance = 2000000000L;     // note the L suffix
unsigned long sizeInBytes = 4294967295UL;
```

### `long long`

* **At least 64 bits** on all modern compilers.
* Use for **very large counts/IDs**, e.g., YouTube views, nanosecond timestamps.

```c
long long views = 9876543210LL;
unsigned long long id = 18446744073709551615ULL;
```

For **large numbers** ‚Äî like YouTube views or population count.

```c
#include <stdio.h>
int main() {
    long l = 2147483647;        // near max of int
    long long ll = 9223372036854775807LL; // very large number

    printf("long = %ld\n", l);
    printf("long long = %lld\n", ll);

    return 0;
}
```

**Output:**

```
long = 2147483647
long long = 9223372036854775807
```

üí° Explanation:

* `long` is often the same as `int` (4 bytes) on 32-bit systems,
  but may be 8 bytes on 64-bit.
* `long long` is **always at least 8 bytes** ‚Üí fits **huge values**.

üëâ That‚Äôs why YouTube switched to `long long` when views crossed `2,147,483,647`!


### `signed` vs `unsigned`

* `signed` ‚Üí can be **negative or positive** (default for `int`).
* `unsigned` ‚Üí **non-negative only**, but **double** the positive range for the same width.

```c
int temperature = -5;             // signed
unsigned int students = 240;      // cannot be negative
```

> ‚ö†Ô∏è Don‚Äôt make things `unsigned` just because they ‚Äúshouldn‚Äôt be negative‚Äù. It can create **surprising bugs** in comparisons and math (see ¬ß6.3).

By default, integers are **signed** (can be positive or negative).
But if you know values will **never be negative**, use `unsigned` for a larger positive range.

```c
#include <stdio.h>
int main() {
    int signedInt = -10;
    unsigned int unsignedInt = -10; // storing a negative in unsigned

    printf("signed int = %d\n", signedInt);
    printf("unsigned int (with -10) = %u\n", unsignedInt);

    return 0;
}
```

**Output (typical):**

```
signed int = -10
unsigned int (with -10) = 4294967286
```

üí° Explanation:

* `signed int` stores both positive and negative.
* `unsigned int` only stores 0 and positive values.
* If you put a negative into `unsigned`, it shows up as a **huge positive number** because of how binary wrapping works.

üëâ Example use: **Attendance counter**. Can‚Äôt go negative ‚Üí use `unsigned int`.

---

## 3) Sizes are implementation‚Äëdefined (be portable)

Common data model cheatsheet (not a guarantee, but typical):

| Platform model                | `int` | `long` | `long long` |
| ----------------------------- | ----- | ------ | ----------- |
| **ILP32** (old 32‚Äëbit)        | 32    | 32     | 64          |
| **LP64** (Linux/macOS 64‚Äëbit) | 32    | 64     | 64          |
| **LLP64** (Windows 64‚Äëbit)    | 32    | 32     | 64          |

**Rule of thumb for students:**

* Use `int` for normal counters and small numbers.
* Use `long long` for ‚Äúhuge‚Äù numbers (views, IDs).
* Use `size_t` for **sizes/lengths** (we‚Äôll meet it later with arrays/memory).
* **Check** with `sizeof` and **limits** via `<limits.h>` when you care.

---

## 4) Ranges (typical) & how to check them

Typical (but not promised!) ranges:

* `short` : ‚àí32768 ‚Ä¶ +32767 ; `unsigned short` : 0 ‚Ä¶ 65535
* `int`   : ‚àí2,147,483,648 ‚Ä¶ +2,147,483,647 ; `unsigned int` : 0 ‚Ä¶ 4,294,967,295
* `long long` : ‚àí9.22e18 ‚Ä¶ +9.22e18 ; `unsigned long long` : 0 ‚Ä¶ \~1.84e19

**Portable way** (recommended for serious work):

```c
#include <stdio.h>
#include <limits.h>

int main() {
    printf("INT_MIN = %d, INT_MAX = %d\n", INT_MIN, INT_MAX);
    printf("LLONG_MIN = %lld, LLONG_MAX = %lld\n", LLONG_MIN, LLONG_MAX);
    printf("UINT_MAX = %u\n", UINT_MAX);
    printf("ULLONG_MAX = %llu\n", ULLONG_MAX);
    return 0;
}
```

---

## 5) Integer literals & suffixes (crucial!)

Tell the compiler what **type** a literal should be:

* `L` / `LL` ‚Üí `long` / `long long`
* `U` ‚Üí `unsigned`
* You can combine: `UL`, `LLU`, etc.

```c
123          // int
123U         // unsigned int
123L         // long
123LL        // long long
123UL        // unsigned long
123ULL       // unsigned long long
0xFFU        // unsigned int (hex literal)
```

> Use suffixes when you **need the wider type** or unsigned behavior.

---

## 6) Checking Sizes with `sizeof`

Instead of guessing, use `sizeof` to see how big each type is on your system.

```c
#include <stdio.h>
int main() {
    printf("Size of short = %zu bytes\n", sizeof(short));
    printf("Size of int = %zu bytes\n", sizeof(int));
    printf("Size of long = %zu bytes\n", sizeof(long));
    printf("Size of long long = %zu bytes\n", sizeof(long long));
    printf("Size of unsigned int = %zu bytes\n", sizeof(unsigned int));
    return 0;
}
```

**Possible Output (on 64-bit system):**

```
Size of short = 2 bytes
Size of int = 4 bytes
Size of long = 8 bytes
Size of long long = 8 bytes
Size of unsigned int = 4 bytes
```

üí° Different systems may give different results ‚Äî this is why **portable code** uses `sizeof`.

---

## 7) `printf` / `scanf` format specifiers (must‚Äëknow)

Using the **wrong specifier** gives garbage output or UB.

### `printf` (output)

| Type                 | Specifier |
| -------------------- | --------- |
| `short`              | `%hd`     |
| `unsigned short`     | `%hu`     |
| `int`                | `%d`      |
| `unsigned int`       | `%u`      |
| `long`               | `%ld`     |
| `unsigned long`      | `%lu`     |
| `long long`          | `%lld`    |
| `unsigned long long` | `%llu`    |

### `scanf` (input)

| Type                 | Specifier |
| -------------------- | --------- |
| `short`              | `%hd`     |
| `unsigned short`     | `%hu`     |
| `int`                | `%d`      |
| `unsigned int`       | `%u`      |
| `long`               | `%ld`     |
| `unsigned long`      | `%lu`     |
| `long long`          | `%lld`    |
| `unsigned long long` | `%llu`    |

> **Double vs float:** `printf` uses `%f` for `double` (because of default promotions). For `scanf`, use `%f` for `float`, `%lf` for `double`.

---

## 8) Hands‚Äëon demos

### 8.1 Sizes & limits on *your* machine

```c
#include <stdio.h>
#include <limits.h>

int main() {
    printf("sizeof(short) = %zu\n", sizeof(short));
    printf("sizeof(int) = %zu\n", sizeof(int));
    printf("sizeof(long) = %zu\n", sizeof(long));
    printf("sizeof(long long) = %zu\n", sizeof(long long));
    printf("INT_MIN = %d, INT_MAX = %d\n", INT_MIN, INT_MAX);
    printf("LLONG_MIN = %lld, LLONG_MAX = %lld\n", LLONG_MIN, LLONG_MAX);
    return 0;
}
```

### 8.2 Unsigned wrap vs signed UB

```c
#include <stdio.h>
#include <limits.h>

int main() {
    unsigned int uu = 0;
    uu--;
    printf("unsigned wrap: %u (UINT_MAX=%u)\n", uu, UINT_MAX);

    int s = INT_MAX;
    // s++; // avoid: signed overflow is undefined
    printf("signed max: %d\n", s);
    return 0;
}
```

### 8.3 Signed/unsigned comparison trap

```c
#include <stdio.h>

int main() {
    unsigned int a = 10;
    int b = -1;

    // b is converted to a huge unsigned value before comparison
    printf("(b < a) ? %s\n", (b < a) ? "true" : "false"); // often false
    return 0;
}
```

### 8.4 Correct specifiers (printf/scanf)

```c
#include <stdio.h>

int main() {
    short s; unsigned long long big;
    scanf("%hd %llu", &s, &big);   // input
    printf("s=%hd, big=%llu\n", s, big); // output
    return 0;
}
```

### 8.5 Bitmasks (why unsigned is perfect)

```c
#include <stdio.h>

int main() {
    unsigned int PERM_READ  = 1u << 0;
    unsigned int PERM_WRITE = 1u << 1;
    unsigned int PERM_EXEC  = 1u << 2;

    unsigned int user = PERM_READ | PERM_WRITE; // has R+W
    printf("Has exec? %s\n", (user & PERM_EXEC) ? "yes" : "no");
    return 0;
}
```

---

## 9) Choosing the right type (quick guide)

* **Loop counters / small math** ‚Üí `int`
* **Large IDs / timestamps / view counts** ‚Üí `long long` / `unsigned long long`
* **Quantities that can‚Äôt be negative** ‚Üí consider `unsigned` (but beware comparisons)
* **Array lengths / memory sizes** ‚Üí later we‚Äôll use `size_t`
* **Binary flags/permissions** ‚Üí `unsigned` + bit operations

---

## 10) Common mistakes (and fixes)

1. **Wrong format specifier**

```c
long long x = 42;
printf("%d", x);      // ‚ùå
printf("%lld", x);    // ‚úÖ
```

2. **Comparing signed with unsigned**

```c
int n = -1; unsigned m = 1;
if (n < m) { /* might be false due to conversion */ } // ‚ùå
```

3. **Assuming sizes**
   Don‚Äôt assume ‚Äú`long` is 64‚Äëbit everywhere.‚Äù Always check with `sizeof` if it matters.

4. **Relying on signed overflow**
   Never depend on signed overflow ‚Äúwrapping‚Äù. It‚Äôs undefined.

---

### Recap

* Modifiers let you scale **range** and clarify **intent**.
* Sizes and ranges **depend on platform**‚Äîlearn to use `sizeof` and `<limits.h>`.
* Be careful with **signed/unsigned mixing** and **format specifiers**.
* For truly big counts, **use `long long`** (and literal suffix `LL` / `ULL`).

---
