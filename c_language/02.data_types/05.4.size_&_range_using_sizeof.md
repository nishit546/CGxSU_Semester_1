# 05.4: Size & Range of Each Type (using `sizeof`)

In C, **types control memory**. To write safe, efficient programs, you must know:

1. **How many bytes** a type uses ‚Üí with `sizeof`
2. **What range of values** it can hold ‚Üí with `<limits.h>` and `<float.h>`

We‚Äôll learn both by running tiny programs and reading their output.

---

## 1) The `sizeof` operator (quick facts)

* It returns the **size in bytes** of a **type** or an **expression**.
* Result type is `size_t` (an **unsigned** integer type).
* Syntax:

  * `sizeof (type)`  ‚Üê parentheses required
  * `sizeof expression`  ‚Üê parentheses optional, but common

**Examples**

```c
sizeof(int)        // size of type int
sizeof x           // size of the expression/variable x
sizeof(3.14)       // size of the double literal 3.14 (usually 8)
sizeof "Hi"        // size of the string literal array: 3 ('H','i','\0')
```

> Tip: When printing `sizeof` results, use **`%zu`** (for `size_t`).

---

## 2) Print sizes of common types (your machine!)

```c
#include <stdio.h>

int main() {
    printf("char:            %zu byte\n",  sizeof(char));
    printf("short:           %zu bytes\n", sizeof(short));
    printf("int:             %zu bytes\n", sizeof(int));
    printf("long:            %zu bytes\n", sizeof(long));
    printf("long long:       %zu bytes\n", sizeof(long long));
    printf("float:           %zu bytes\n", sizeof(float));
    printf("double:          %zu bytes\n", sizeof(double));
    printf("long double:     %zu bytes\n", sizeof(long double));
    return 0;
}
```

**Typical output (64‚Äëbit Linux/macOS):**

```
char:            1 byte
short:           2 bytes
int:             4 bytes
long:            8 bytes
long long:       8 bytes
float:           4 bytes
double:          8 bytes
long double:     16 bytes
```

**Typical output (64‚Äëbit Windows):**

```
char:            1 byte
short:           2 bytes
int:             4 bytes
long:            4 bytes
long long:       8 bytes
float:           4 bytes
double:          8 bytes
long double:     8 or 16 bytes (varies by compiler)
```

üí° **Why different?** C leaves some sizes **implementation-defined**. That‚Äôs why we **measure** with `sizeof` instead of guessing.

---

## 3) Ranges for integers ‚Äî `<limits.h>`

Use macros from `<limits.h>` to print the **minimum** and **maximum** representable values.

```c
#include <stdio.h>
#include <limits.h>

int main() {
    printf("signed char:   %d to %d\n",   SCHAR_MIN,  SCHAR_MAX);
    printf("unsigned char: %u to %u\n",   0u,         UCHAR_MAX);

    printf("short:         %d to %d\n",   SHRT_MIN,   SHRT_MAX);
    printf("unsigned short:%u to %u\n",   0u,         USHRT_MAX);

    printf("int:           %d to %d\n",   INT_MIN,    INT_MAX);
    printf("unsigned int:  %u to %u\n",   0u,         UINT_MAX);

    printf("long:          %ld to %ld\n", LONG_MIN,   LONG_MAX);
    printf("unsigned long: %lu to %lu\n", 0ul,        ULONG_MAX);

    printf("long long:     %lld to %lld\n", LLONG_MIN, LLONG_MAX);
    printf("unsigned long long: %llu to %llu\n", 0ull, ULLONG_MAX);
    return 0;
}
```

**Typical output (abridged):**

```
signed char:   -128 to 127
unsigned char: 0 to 255
short:         -32768 to 32767
unsigned short:0 to 65535
int:           -2147483648 to 2147483647
unsigned int:  0 to 4294967295
long:          -9223372036854775808 to 9223372036854775807   (LP64)
unsigned long: 0 to 18446744073709551615
long long:     -9223372036854775808 to 9223372036854775807
unsigned long long: 0 to 18446744073709551615
```

> If your `long` prints the same as `int`, that‚Äôs fine‚Äîit‚Äôs platform‚Äëdependent.

---

## 4) Ranges & precision for floating types ‚Äî `<float.h>`

`<float.h>` tells you **precision** and **min/max exponents** for `float`, `double`, `long double`.

```c
#include <stdio.h>
#include <float.h>

int main() {
    printf("float:  size=%zu, digits‚âà%d, min‚âà%e, max‚âà%e\n",
           sizeof(float),  FLT_DIG,  FLT_MIN,  FLT_MAX);
    printf("double: size=%zu, digits‚âà%d, min‚âà%e, max‚âà%e\n",
           sizeof(double), DBL_DIG,  DBL_MIN,  DBL_MAX);
    printf("long double: size=%zu, digits‚âà%d, min‚âà%Le, max‚âà%Le\n",
           sizeof(long double), LDBL_DIG, LDBL_MIN, LDBL_MAX);
    return 0;
}
```

**Sample output (conceptual):**

```
float:  size=4, digits‚âà6, min‚âà1.175494e-38, max‚âà3.402823e+38
double: size=8, digits‚âà15, min‚âà2.225074e-308, max‚âà1.797693e+308
long double: size=16, digits‚âà18, min‚âà3.362103e-4932, max‚âà1.189731e+4932
```

* `FLT_DIG` ‚âà **significant decimal digits** you can trust (float ‚âà 6‚Äì7).
* `DBL_DIG` for `double` (‚âà 15‚Äì16).
* Use `%e`/`%Le` to print scientific notation.

---

## 5) `sizeof` with arrays, strings, and expressions

### 5.1 Arrays (great trick)

```c
#include <stdio.h>

int main() {
    int a[] = {10, 20, 30, 40, 50};
    size_t bytes = sizeof a;                   // total bytes of the array
    size_t count = sizeof a / sizeof a[0];     // number of elements
    printf("Array bytes=%zu, elements=%zu\n", bytes, count);
    return 0;
}
```

**Output (typical):**

```
Array bytes=20, elements=5
```

> ‚ö†Ô∏è **Important:** Inside a **function parameter**, an array **decays to a pointer**, so `sizeof` won‚Äôt give total bytes there. Use the trick **only** where the array is in scope as an actual array (e.g., in the same function where it‚Äôs declared).

### 5.2 `char`, character constants, and string literals

```c
#include <stdio.h>

int main() {
    printf("sizeof(char)      = %zu\n", sizeof(char));
    printf("sizeof('A')       = %zu  // character constant is int in C\n", sizeof('A'));
    printf("sizeof(\"A\")      = %zu  // string literal: 'A' + '\\0'\n", sizeof("A"));
    printf("sizeof(\"Hello\")  = %zu  // 'H','e','l','l','o','\\0'\n", sizeof("Hello"));
    return 0;
}
```

**Typical output:**

```
sizeof(char)      = 1
sizeof('A')       = 4
sizeof("A")       = 2
sizeof("Hello")   = 6
```

* In C, a character **literal** like `'A'` has type **`int`**, not `char`.
* A **string literal** is an **array of char** including the terminating `'\0'`.

### 5.3 Expressions vs Types

```c
int x = 5;
printf("%zu\n", sizeof x);        // size of the expression (int)
printf("%zu\n", sizeof (int));    // size of the type int
```

---

## 6) Common mistakes (and how to avoid them)

1. **Wrong format for `sizeof`**

   ```c
   printf("%d", sizeof(int));  // ‚ùå
   printf("%zu", sizeof(int)); // ‚úÖ use %zu for size_t
   ```

2. **Expecting the same sizes everywhere**

   * Don‚Äôt assume `long` is 8 bytes on Windows (often 4).
   * Always **check with `sizeof`** if it matters.

3. **Using `sizeof` on arrays after decay**

   ```c
   void f(int arr[]) { printf("%zu\n", sizeof arr); } // ‚ùå prints pointer size
   ```

   Use the count trick **only** where the array is declared:

   ```c
   size_t n = sizeof arr / sizeof arr[0];
   ```

4. **Forgetting `'\0'` in string length**

   * `sizeof "Hi"` is 3 (`'H','i','\0'`), not 2.

---
