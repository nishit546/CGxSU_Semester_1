# 05.5: Integer Overflow and Underflow

Every integer type in C has a **fixed range** (decided by its size in bytes).
When a calculation goes **beyond the maximum** ‚Üí **overflow**.
When it goes **below the minimum** ‚Üí **underflow**.

Think of it like a **car odometer**:

* After 9999 ‚Üí it rolls back to 0000 (overflow).
* Going ‚Äúbelow‚Äù 0000 ‚Üí rolls back to 9999 (underflow).

---

## 1. Signed Overflow Example

```c
#include <stdio.h>
#include <limits.h>

int main() {
    int max = INT_MAX;   // largest signed int
    printf("INT_MAX = %d\n", max);

    int overflow = max + 1;   // going beyond max
    printf("After overflow: %d\n", overflow);

    return 0;
}
```

**Possible Output (32-bit signed int):**

```
INT_MAX = 2147483647
After overflow: -2147483648
```

üí° Explanation:

* `int` (4 bytes) ranges from **-2147483648 to 2147483647**.
* Adding 1 beyond the max ‚Äúwraps‚Äù to the minimum value.

üëâ This behavior is **undefined in C standard** for signed overflow,
but on most compilers it behaves like binary wrap-around (two‚Äôs complement).

---

## 2. Signed Underflow Example

```c
#include <stdio.h>
#include <limits.h>

int main() {
    int min = INT_MIN;   // smallest signed int
    printf("INT_MIN = %d\n", min);

    int underflow = min - 1;   // going below min
    printf("After underflow: %d\n", underflow);

    return 0;
}
```

**Output:**

```
INT_MIN = -2147483648
After underflow: 2147483647
```

üí° Explanation:
Subtracting 1 from minimum rolls back to maximum.

---

## 3. Unsigned Overflow Example

Unsigned integers are simpler: they **always wrap around** in modulo arithmetic.

```c
#include <stdio.h>
#include <limits.h>

int main() {
    unsigned int max = UINT_MAX;   // largest unsigned int
    printf("UINT_MAX = %u\n", max);

    unsigned int overflow = max + 1;
    printf("After overflow: %u\n", overflow);

    return 0;
}
```

**Output (32-bit unsigned int):**

```
UINT_MAX = 4294967295
After overflow: 0
```

üí° Explanation:
Unsigned integers follow **modulo 2^n arithmetic**.

* For 32-bit: range = `0 ‚Ä¶ 4294967295`.
* Add 1 beyond ‚Üí wraps back to 0.

---

## 4. Unsigned Underflow Example

```c
#include <stdio.h>
int main() {
    unsigned int x = 0;
    printf("x = %u\n", x);

    unsigned int underflow = x - 1;
    printf("After underflow: %u\n", underflow);

    return 0;
}
```

**Output:**

```
x = 0
After underflow: 4294967295
```

üí° Explanation:

* Since negatives don‚Äôt exist in unsigned, going below 0 wraps to the maximum.

---

## 5. Real-world Example: Instagram Likes Counter

Imagine Instagram storing likes in a `32-bit int`.
If a reel crosses **2,147,483,647 likes** ‚Üí it overflows into a negative number.

That‚Äôs why **YouTube views bug** happened in 2014 when **Gangnam Style** broke `2,147,483,647` views ‚Üí they upgraded to `long long`.

---

## 6. Detecting & Preventing Overflow

1. **Check before arithmetic**

   ```c
   if (a > INT_MAX - b) {
       printf("Overflow will happen!\n");
   }
   else {
       int sum = a + b;
   }
   ```

2. **Use larger types**

   * If `int` is not enough, use `long long`.

3. **Use unsigned when negatives don‚Äôt make sense**

   * Example: counters, array indices.

---

## 7. Quick Recap

* **Signed overflow/underflow** ‚Üí wraps around (but technically undefined by standard).
* **Unsigned overflow/underflow** ‚Üí always modulo arithmetic.
* Always check limits with `<limits.h>`.
* Real apps (Instagram, YouTube) had bugs due to overflow.

---
