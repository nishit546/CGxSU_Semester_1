# 16.4: String Handling Functions (`<string.h>`)

The C standard library gives you essential tools to **measure**, **copy**, **append**, and **compare** strings. These are simple yet sharp—use them correctly and they’ll serve you well; misuse them and you’ll meet bugs or crashes.

We’ll cover the “big four” with **live code**, **iteration traces**, and **pitfalls**:

* `strlen` — length of a C‑string (before `'\0'`)
* `strcpy` — copy `"source"` → `dest`
* `strcat` — append `"source"` to end of `dest`
* `strcmp` — compare two strings lexicographically

> Reminder: A **C‑string** is a **char array terminated by `'\0'`**.

---

## 1) `strlen` — Get string length

**Prototype:** `size_t strlen(const char *s);`
Counts characters **until the first `'\0'`** (does not include terminator).

```c
#include <stdio.h>
#include <string.h>

int main() {
    char s[] = "CodingGita";
    size_t L = strlen(s);

    printf("String: \"%s\"\n", s);
    printf("Length: %zu\n\n", L);

    // How strlen works (roughly)
    size_t i = 0;
    while (s[i] != '\0') {
        // Trace: i=0:'C', 1:'o', 2:'d', ..., 9:'a'; stop at i=10:'\0'
        i++;
    }
    printf("Manual length = %zu\n", i);
    return 0;
}
```

**Output**

```
String: "CodingGita"
Length: 10

Manual length = 10
```

### Pitfalls (strlen)

* If the string **lacks `'\0'`**, `strlen` runs into **random memory** → undefined behavior (UB).
* `strlen` is **O(n)**; avoid calling it repeatedly in loops. Cache it once.
* Don’t confuse with `sizeof(array)`:

  * `sizeof("Hi")` is **3** (`'H','i','\0'`)
  * `strlen("Hi")` is **2**

---

## 2) `strcpy` — Copy source to destination

**Prototype:** `char *strcpy(char *dest, const char *src);`
Copies bytes from `src` into `dest`, including the **terminating `'\0'`**.

```c
#include <stdio.h>
#include <string.h>

int main() {
    char dest[20];                 // big enough buffer
    const char *src = "CodingGita";

    // Rough behavior:
    // Copy 'C','o','d','i','n','g','G','i','t','a','\0'
    strcpy(dest, src);

    printf("src  = \"%s\"\n", src);
    printf("dest = \"%s\"\n", dest);
    return 0;
}
```

**Output**

```
src  = "CodingGita"
dest = "CodingGita"
```

### Iteration idea (what strcpy does internally)

```
i=0: dest[0]='C'
i=1: dest[1]='o'
...
i=9: dest[9]='a'
i=10: dest[10]='\0' → stop
```

### Pitfalls (strcpy)

* **Buffer overflow:** `dest` must be **large enough** for all characters **+ `'\0'`**.

  ```c
  char small[5];
  // strcpy(small, "Hello"); // ❌ writes 6 bytes → overflow → UB
  ```

* **Modifying string literals**:

  ```c
  // char *d = "CG";       // literal in read-only memory
  // strcpy(d, "Hi");      // ❌ UB, likely crash
  ```

  Use a **writable array**:

  ```c
  char d[10] = "CG";
  strcpy(d, "Hi");         // ✅ ok
  ```

* **Overlapping memory is UB**: If `dest` and `src` overlap (same buffer with offsets), behavior is undefined. (Strings rarely need overlap moves; if you manipulate raw bytes, use `memmove`.)

---

## 3) `strcat` — Append source to end of destination

**Prototype:** `char *strcat(char *dest, const char *src);`
Finds the **end of `dest`** (its `'\0'`), then copies `src` **including** its `'\0'`.

```c
#include <stdio.h>
#include <string.h>

int main() {
    char dest[30] = "Coding";  // must start as a proper string (has '\0')
    const char *src = "Gita";

    // Steps inside strcat:
    // 1) Find end of dest: "Coding\0"
    // 2) Copy 'G','i','t','a','\0' after it
    strcat(dest, src);

    printf("After strcat: \"%s\"\n", dest); // "CodingGita"
    return 0;
}
```

**Output**

```
After strcat: "CodingGita"
```

### Iteration idea

```
Find end: dest[6] is '\0'
Copy:
 dest[6]='G'
 dest[7]='i'
 dest[8]='t'
 dest[9]='a'
 dest[10]='\0'
```

### Pitfalls (strcat)

* **Capacity**: `dest` must have **enough free space** for existing contents **+** `src` **+** `'\0'`.

  ```c
  char d[8] = "Code";
  // strcat(d, "Gita"); // ❌ needs 4+4+1 = 9 bytes; only 8 available → overflow
  ```

* **`dest` must already be a proper string** (contain a `'\0'` somewhere). Uninitialized `dest` = UB.

* For **bounded appends**, see `strncat` caution below.

---

## 4) `strcmp` — Compare two strings

**Prototype:** `int strcmp(const char *s1, const char *s2);`
Compares lexicographically (dictionary order using byte values). Returns:

* **`0`** if equal
* **`< 0`** if `s1 < s2`
* **`> 0`** if `s1 > s2`

```c
#include <stdio.h>
#include <string.h>

int main() {
    printf("strcmp(\"CG\", \"CG\")   = %d\n", strcmp("CG", "CG"));   // 0
    printf("strcmp(\"CG\", \"CGA\")  = %d\n", strcmp("CG", "CGA"));  // <0
    printf("strcmp(\"CGA\", \"CG\")  = %d\n", strcmp("CGA", "CG"));  // >0
    printf("strcmp(\"Apple\", \"Banana\") = %d\n", strcmp("Apple","Banana")); // <0
    printf("strcmp(\"abc\", \"Abc\") = %d\n", strcmp("abc","Abc"));  // >0 (lowercase > uppercase in ASCII)
    return 0;
}
```

**Typical Output**

```
strcmp("CG", "CG")   = 0
strcmp("CG", "CGA")  = -1  (any negative)
strcmp("CGA", "CG")  = 1   (any positive)
strcmp("Apple", "Banana") = -1
strcmp("abc", "Abc") = 1
```

> Only the **sign** matters, not the exact number. Don’t check `== 1` or `== -1`—check `< 0`, `== 0`, or `> 0`.

### Common mistakes (strcmp)

* **Using `==` to compare strings** (compares pointers, not contents):

  ```c
  char a[] = "CG", b[] = "CG";
  // if (a == b) ...       // ❌ compares addresses
  if (strcmp(a, b) == 0) {  // ✅ compares contents
      /* equal */
  }
  ```

* **Case sensitivity**: `'a'` (97) is greater than `'A'` (65). If you want case‑insensitive, use platform-specific `strcasecmp`/`_stricmp` (non‑standard), or normalize case yourself.

---

## 5) Safer / bounded variants (and their caveats)

### `strncpy(dest, src, n)`

* Copies **up to `n` chars**.
* **Does NOT guarantee `'\0'`** if `src` length ≥ `n`! You must terminate manually.

```c
char d[6];
strncpy(d, "CodingGita", 5); // copies "Codin" (no '\0' yet!)
d[5] = '\0';                 // ✅ ensure termination
```

Also note: if `src` is shorter than `n`, `strncpy` **pads with `'\0'`**—can be slower on large `n`.

### `strncat(dest, src, n)`

* Appends **up to `n` chars** from `src`, then **adds `'\0'`**.
* You must ensure **remaining capacity**:
  `existing_len(dest) + min(n, strlen(src)) + 1 <= sizeof(dest)`.

```c
char d[10] = "CG";
strncat(d, " Portal", 7);  // appends up to 7 chars
// Be sure buffer is big enough!
```

### `strncmp(s1, s2, n)`

* Compares up to `n` chars (or until `'\0'`). Same return rules as `strcmp`.

> Many projects today prefer **`snprintf`** to build strings safely:

```c
char buf[32];
snprintf(buf, sizeof buf, "%s-%s", "Coding", "Gita"); // auto-bounded
```

(`snprintf` is standard C99, very handy for composing text without overflow.)

---

## 6) Putting it together — mini lab (with traces)

```c
#include <stdio.h>
#include <string.h>

int main() {
    char dest[32] = "Coding";          // has '\0' at index 6
    const char *src = "Gita";

    // A) measure
    size_t a = strlen(dest);           // 6
    size_t b = strlen(src);            // 4
    printf("len(dest)=%zu, len(src)=%zu\n", a, b);

    // B) append
    // Trace: find dest end at 6, copy src incl. '\0' at 6..10
    strcat(dest, src);
    printf("after strcat: \"%s\"\n", dest);  // "CodingGita"

    // C) copy
    char copy[32];
    // Trace: copy 'C','o','d','i','n','g','G','i','t','a','\0'
    strcpy(copy, dest);
    printf("after strcpy: \"%s\"\n", copy);

    // D) compare
    int cmp1 = strcmp(copy, "CodingGita");
    int cmp2 = strcmp(copy, "CodingGitaX");
    printf("strcmp(copy,\"CodingGita\")  = %d (==0 means equal)\n", cmp1);
    printf("strcmp(copy,\"CodingGitaX\") = %d (<0 means copy < rhs)\n", cmp2);

    return 0;
}
```

**Sample Output**

```
len(dest)=6, len(src)=4
after strcat: "CodingGita"
after strcpy: "CodingGita"
strcmp(copy,"CodingGita")  = 0 (==0 means equal)
strcmp(copy,"CodingGitaX") = -1 (<0 means copy < rhs)
```

---

## 7) Quick checklist (pin it!)

* `strlen(s)` → count until `'\0'` (O(n)); don’t use on unterminated buffers.
* `strcpy(dest, src)` → **dest big enough**; copies `'\0'`.
* `strcat(dest, src)` → dest must be a valid C‑string with **spare capacity**.
* `strcmp(a, b)` → returns `<0 / 0 / >0`; use sign, **not** specific numbers.
* Avoid overflow: prefer size‑aware patterns (`snprintf`, careful `strn*` usage).
* **Never** write into string literals (`char *p = "text";`) — UB/crash.
* Overlap with `strcpy/strcat` is UB; for raw bytes use `memmove`.

---

