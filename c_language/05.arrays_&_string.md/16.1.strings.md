# 16.1: Strings

Strings power everything from **WhatsApp messages** to **usernames on CodingGita**. In C, a string is just a **character array that ends with `'\0'`**.

---

## 1) Memory model of strings (what sits in RAM)

```c
#include <stdio.h>
int main() {
    char name[] = "CodingGita"; // 'C','o','d','i','n','g','G','i','t','a','\0'

    // Show each character, its ASCII, and address
    for (int i = 0; i <= 10; i++) {
        // Iteration idea:
        // i=0:'C'(67), i=1:'o'(111), ..., i=9:'a'(97), i=10:'\0'(0)
        printf("i=%2d  char=%c  ascii=%3d  addr=%p\n",
               i, name[i], (int)name[i], (void*)&name[i]);
    }

    // Print as string (stops at '\0')
    printf("\nAs string: %s\n", name);
    return 0;
}
```

### Sample Output (addresses vary)

```
i= 0  char=C  ascii= 67  addr=0x7ffc1a80f7a0
i= 1  char=o  ascii=111  addr=0x7ffc1a80f7a1
i= 2  char=d  ascii=100  addr=0x7ffc1a80f7a2
i= 3  char=i  ascii=105  addr=0x7ffc1a80f7a3
i= 4  char=n  ascii=110  addr=0x7ffc1a80f7a4
i= 5  char=g  ascii=103  addr=0x7ffc1a80f7a5
i= 6  char=G  ascii= 71  addr=0x7ffc1a80f7a6
i= 7  char=i  ascii=105  addr=0x7ffc1a80f7a7
i= 8  char=t  ascii=116  addr=0x7ffc1a80f7a8
i= 9  char=a  ascii= 97  addr=0x7ffc1a80f7a9
i=10  char=   ascii=  0  addr=0x7ffc1a80f7aa   <-- '\0'

As string: CodingGita
```

---

## 2) Declaring strings (with and without size)

```c
#include <stdio.h>
int main() {
    // A) Let compiler count (safest)
    char course[] = "BTech";     // 6 bytes incl. '\0'

    // B) Explicit size (remember +1 for '\0')
    char ok1[6] = "BTech";       // ✅ fits exactly
    // char bad1[5] = "BTech";   // ❌ too small (uncomment to see compile error)

    // C) Manual list (must add '\0' yourself)
    char dept_ok[4] = {'C','S','E','\0'};  // ✅
    char dept_bad[3] = {'C','S','E'};      // ❌ unsafe as %s (no terminator)

    printf("course=%s\nok1=%s\ndept_ok=%s\n", course, ok1, dept_ok);

    // Printing dept_bad with %s is UB; instead, show raw bytes safely:
    printf("dept_bad bytes: [%c][%c][%c]\n", dept_bad[0], dept_bad[1], dept_bad[2]);

    return 0;
}
```

### Sample Output

```
course=BTech
ok1=BTech
dept_ok=CSE
dept_bad bytes: [C][S][E]
```

> Note: Printing `dept_bad` with `%s` could spew garbage because it lacks `'\0'`.

---

## 3) Common mistakes (with visible consequences)

### 3.1 Array too small

```c
// char a[5] = "Hello";   // ❌ needs 6 bytes: 'H','e','l','l','o','\0'
```

**Fix:** `char a[6] = "Hello";` or `char a[] = "Hello";`

---

### 3.2 Missing `'\0'` when listing chars

```c
#include <stdio.h>
int main() {
    char w_bad[4] = {'C','S','E','!'};     // ❌ no '\0'
    char w_ok[5]  = {'C','S','E','!','\0'}; // ✅ ends properly

    // Printing bad as %s is undefined; we visualize both anyway:
    printf("w_ok as string: %s\n", w_ok);
    printf("w_bad raw bytes: [%c][%c][%c][%c]\n", w_bad[0], w_bad[1], w_bad[2], w_bad[3]);
    return 0;
}
```

**Output**

```
w_ok as string: CSE!
w_bad raw bytes: [C][S][E][!]
```

> If you try `printf("%s\n", w_bad);` you may see **garbage beyond `!`**.

---

### 3.3 Overwriting the terminator (off‑by‑one)

```c
#include <stdio.h>
int main() {
    char s[6] = "Hello"; // s[0..4]='H','e','l','l','o', s[5]='\0'
    s[5] = '!';          // ❌ now no terminator at the end
    printf("After overwrite (as bytes): [%c][%c][%c][%c][%c][%c]\n",
           s[0],s[1],s[2],s[3],s[4],s[5]);
    // Avoid printing as %s now; it might run past end.
    return 0;
}
```

**Output**

```
After overwrite (as bytes): [H][e][l][l][o][!]
```

---

### 3.4 `sizeof` vs `strlen`

```c
#include <stdio.h>
#include <string.h>
int main() {
    char s[] = "Coding";        // 7 bytes including '\0'
    printf("sizeof(s)=%zu\n", sizeof s); // 7
    printf("strlen(s)=%zu\n", strlen(s)); // 6
    return 0;
}
```

**Output**

```
sizeof(s)=7
strlen(s)=6
```

---

## 4) Iterating through a string (three patterns)

### 4.1 Index until `'\0'`

```c
#include <stdio.h>
int main() {
    char name[] = "CodingGita";
    for (int i = 0; name[i] != '\0'; i++) {
        // i=0:'C', 1:'o', ..., 9:'a', then i=10 hits '\0' and stops
        printf("name[%d]=%c\n", i, name[i]);
    }
    return 0;
}
```

**Output (snippet)**

```
name[0]=C
name[1]=o
...
name[9]=a
```

---

### 4.2 Precompute length once

```c
#include <stdio.h>
#include <string.h>
int main() {
    char s[] = "CG Portal";
    size_t n = strlen(s); // 9 (includes space)
    for (size_t i = 0; i < n; i++) {
        printf("%c", s[i]);
    }
    printf("\n");
    return 0;
}
```

**Output**

```
CG Portal
```

---

### 4.3 Count length manually (what `strlen` does)

```c
#include <stdio.h>
int main() {
    char s[] = "Hello";
    int len = 0;
    // Trace: len grows until we hit '\0'
    while (s[len] != '\0') {
        // len=0:'H' →1, len=1:'e' →2, len=2:'l'→3, len=3:'l'→4, len=4:'o'→5
        len++;
    }
    printf("Length=%d\n", len); // 5
    return 0;
}
```

**Output**

```
Length=5
```

---

## 5) Worked examples (I/O + comments)

### 5.1 Print index + ASCII of each char

```c
#include <stdio.h>
int main() {
    char s[] = "CSE";
    for (int i = 0; s[i] != '\0'; i++) {
        // i=0:'C'(67), i=1:'S'(83), i=2:'E'(69)
        printf("i=%d  char=%c  ascii=%d\n", i, s[i], (int)s[i]);
    }
    return 0;
}
```

**Output**

```
i=0  char=C  ascii=67
i=1  char=S  ascii=83
i=2  char=E  ascii=69
```

---

### 5.2 Replace spaces with underscores (in‑place)

```c
#include <stdio.h>
int main() {
    char s[] = "Coding Gita Portal";
    for (int i = 0; s[i] != '\0'; i++) {
        // if current char is space, replace
        if (s[i] == ' ') s[i] = '_';
    }
    printf("%s\n", s); // Coding_Gita_Portal
    return 0;
}
```

**Output**

```
Coding_Gita_Portal
```

---

### 5.3 Count vowels

```c
#include <stdio.h>
int main() {
    char s[] = "Welcome to CodingGita";
    int v = 0;
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        // Check both cases
        if (c=='A'||c=='E'||c=='I'||c=='O'||c=='U'||
            c=='a'||c=='e'||c=='i'||c=='o'||c=='u') {
            v++; // increment vowel count
        }
    }
    printf("Vowels=%d\n", v);
    return 0;
}
```

**Output**

```
Vowels=9
```

---

## 6) Mini cheatsheet

* Allocate **length + 1** to fit the `'\0'`.
* `char s[] = "text";` → mutable array, safe to edit chars.
* `char *s = "text";` → points to **string literal** (usually read‑only) — don’t modify (we’ll prove this in the next article).
* `sizeof(array)` includes `'\0'`; `strlen()` doesn’t.
* Iterate until `'\0'`.

---

## 7) Quick self‑checks

1. Is `char id[5] = "CG12";` valid? What about `"CG123"`?
2. Predict output:

```c
char s[] = "Hi";
printf("%zu %zu\n", sizeof s, strlen(s));
```

3. Convert `"Hello World"` → `"Hello_World"` in place.
4. Count digits in `"CG-2025"`.

---
