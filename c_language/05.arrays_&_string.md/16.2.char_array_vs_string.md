# 16.2: Character Arrays vs String Literals in C

In C, we can store strings in **two different ways**:

1. As a **character array** (mutable).
2. As a **string literal** assigned to a pointer (immutable).

Although they look similar, they behave very differently in memory.

---

## 1) Character Array (`char name[] = "Neel";`)

```c
#include <stdio.h>
int main() {
    char name[] = "Neel";  // stored in writable memory (stack)
    name[0] = 'P';         // ✅ allowed: modify array element
    printf("%s\n", name);
    return 0;
}
```

**Output**

```
Peel
```

**Why?**

* `"Neel"` is copied into an **array of chars** in your stack frame.
* Array elements are **modifiable**, so `name[0]='P'` works fine.

### Memory Layout

```
Stack (local array)
+---+---+---+---+---+
| N | e | e | l | \0|
+---+---+---+---+---+
 ^mutable (can change)
```

---

## 2) String Literal (`char *name = "Neel";`)

```c
#include <stdio.h>
int main() {
    char *name = "Neel";   // points to literal in read-only memory
    printf("%s\n", name);
    return 0;
}
```

**Output**

```
Neel
```

But here, `"Neel"` is stored in **read-only memory** (typically the program’s text segment).
`name` is just a pointer to that location.

---

## 3) What if we try to modify a string literal?

```c
#include <stdio.h>
int main() {
    char *name = "Neel";   // pointer → string literal
    name[0] = 'P';         // ❌ undefined behavior
    printf("%s\n", name);
    return 0;
}
```

### Possible outcomes

* Program **crashes** with a **segmentation fault**.
* Or prints garbage.
* Or (rarely) seems to work, but that’s unsafe and undefined.

This happens because the literal `"Neel"` is in **read-only memory**, and writing to it is forbidden.

---

## 4) Side-by-side comparison

| Declaration            | Memory Location        | Mutable? | Example               |
| ---------------------- | ---------------------- | -------- | --------------------- |
| `char arr[] = "Neel";` | Stack/local array      | ✅ Yes    | `arr[0]='P' → "Peel"` |
| `char *ptr = "Neel";`  | Read-only literal area | ❌ No     | `ptr[0]='P' → Crash`  |

---

## 5) Best Practices

* If you need to **modify** a string → use an **array**:

  ```c
  char word[] = "Hello";
  word[0] = 'J';  // works
  ```

* If string is **constant** (just for reading) → use a **pointer**:

  ```c
  const char *msg = "Welcome to CodingGita";
  printf("%s\n", msg);
  ```

  Adding `const` prevents accidental modification.

---

## 6) Demo: Both in One Program

```c
#include <stdio.h>
int main() {
    char arr[] = "Neel";   // mutable
    char *ptr  = "Neel";   // immutable literal

    arr[0] = 'P';  // ✅ modifies array
    printf("arr = %s\n", arr);

    // ptr[0] = 'P';  // ❌ uncomment → likely segmentation fault
    printf("ptr = %s\n", ptr);

    return 0;
}
```

**Safe Output**

```
arr = Peel
ptr = Neel
```

---

## 7) Key Takeaways

* **Array form (`char s[] = "text";`)**

  * String is **copied** into a writable array (stack).
  * Can safely modify characters.

* **Pointer form (`char *s = "text";`)**

  * Points to **string literal** in read-only memory.
  * Modifying is **undefined behavior** → often crashes.

* Always use `const char *` if you don’t intend to modify:

  ```c
  const char *msg = "Hello";  // read-only
  ```

---

