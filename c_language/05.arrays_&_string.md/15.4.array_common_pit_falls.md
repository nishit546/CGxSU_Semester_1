# **15.4: Common Pitfalls in Arrays**

Arrays are very useful, but **beginners often make mistakes** when working with them.
Here we’ll see the **most common errors**, why they happen, and how to fix them.

---

## 1) Array Index Out of Bounds

An array in C has **fixed size**.
Valid indices are from **0 to size-1**. Accessing outside this range is **undefined behavior** (program may crash or print garbage).

```c
#include <stdio.h>
int main() {
    int arr[3] = {10, 20, 30};

    printf("%d\n", arr[0]);   // ✅ valid → 10
    printf("%d\n", arr[2]);   // ✅ valid → 30

    printf("%d\n", arr[3]);   // ❌ invalid, index > 2
    printf("%d\n", arr[-1]);  // ❌ invalid, negative index
    return 0;
}
```

**Possible Output**

```
10
30
32767   // garbage value (varies each run)
0       // also garbage (unpredictable)
```

⚠️ C does **not check bounds** → programmer must ensure index is valid.

---

## 2) Forgetting Array Size

If you declare an array but forget its size or initialize it incorrectly, errors may occur.

```c
int a[];           // ❌ error: size required
int b[3] = {1,2,3}; // ✅ correct
int c[] = {1,2,3};  // ✅ compiler counts size (3)
```

Another mistake: writing more elements than declared.

```c
int d[3] = {1, 2, 3, 4};  // ❌ too many initializers
```

---

## 3) Using Garbage Values (Uninitialized Elements)

If an array is declared but not initialized, elements contain **garbage values**.

```c
#include <stdio.h>
int main() {
    int arr[5];   // uninitialized
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```

**Sample Output (unpredictable)**

```
0 4195712 6 -12 32767
```

✅ Always **initialize arrays** before using them:

```c
int arr[5] = {0};   // sets all elements to 0
```

---

## 4) Difference Between Array Name and Pointer (Brief Mention)

In many contexts, the **array name behaves like a pointer** to its first element.
But they are **not the same thing**.

```c
#include <stdio.h>
int main() {
    int arr[3] = {10, 20, 30};

    printf("%p\n", arr);     // address of first element
    printf("%p\n", &arr[0]); // same address
    printf("%d\n", *arr);    // value at first element → 10

    return 0;
}
```

**Output (example)**

```
0x7ffdfe5c10   // address
0x7ffdfe5c10   // same as above
10
```

⚠️ But unlike real pointers, an array’s size is **fixed** at compile time and cannot be reassigned.

We’ll study this deeply later in **Pointer Unit**.

---

## 5) Mini Practice Tasks

1. Declare an array of size 4. Try printing `arr[4]`. What happens?
2. Initialize only the first 2 elements of `arr[5]`. Print all 5. What values do you see?
3. Declare `int x[3] = {1,2,3};` and print `x`, `&x[0]`, and `*x`. What do they mean?

---

## 6) Key Takeaways

* Array indices go from **0 to size-1**.
* Uninitialized arrays contain **garbage values**.
* Always declare **correct size** and initialize properly.
* Array name often acts like a **pointer to first element**, but arrays and pointers are **different concepts**.

---
