# 06.6: Bitwise Operators in C — With Binary Views

(We’ll use **8‑bit** diagrams for clarity: leading zeros are shown.)

## Legend

* `A = 5  → 0000 0101`
* `B = 3  → 0000 0011`
* Result is shown in **binary and decimal**.

---

## 1) AND `&` — bit is 1 only if **both** are 1

**Binary idea**

```
A = 0000 0101   (5)
B = 0000 0011   (3)
-----------------------
    0000 0001   (1)
```

**Code (with binary in comments)**

```c
#include <stdio.h>
int main() {
    unsigned char A = 5;  // 0000 0101
    unsigned char B = 3;  // 0000 0011

    unsigned char R = A & B; // 0000 0101
                             // 0000 0011
                             // -------- &
                             // 0000 0001  -> 1
    printf("A & B = %u\n", R); // 1
    return 0;
}
```

---

## 2) OR `|` — bit is 1 if **at least one** is 1

**Binary idea**

```
A = 0000 0101   (5)
B = 0000 0011   (3)
-----------------------
    0000 0111   (7)
```

**Code**

```c
unsigned char R = A | B;  // 0000 0101
                          // 0000 0011
                          // -------- |
                          // 0000 0111 -> 7
printf("A | B = %u\n", R); // 7
```

---

## 3) XOR `^` — bit is 1 if bits are **different**

**Binary idea**

```
A = 0000 0101   (5)
B = 0000 0011   (3)
-----------------------
    0000 0110   (6)
```

**Code**

```c
unsigned char R = A ^ B;  // 0000 0101
                          // 0000 0011
                          // -------- ^
                          // 0000 0110 -> 6
printf("A ^ B = %u\n", R); // 6
```

---

## 4) NOT `~` — flips every bit (1→0, 0→1)

**Binary idea (8‑bit view)**

```
A  = 0000 0101   (5)
~A = 1111 1010   (250 as unsigned 8-bit)
```

**Code**

```c
unsigned char A = 5;             // 0000 0101
unsigned char R = (unsigned char)(~A);
// ~A (8-bit): 1111 1010 -> 250
printf("~A = %u\n", R); // 250 (on 8-bit view)
```

> If you use a wider type (like `unsigned int`), you’ll see many more 1s. For teaching, we stick to 8‑bit pictures.

---

## 5) Left Shift `<<` — shift left; fill with 0s (≈ multiply by 2)

**Binary idea**

```
x     = 0000 0101  (5)
x<<1  = 0000 1010 (10)
x<<2  = 0001 0100 (20)
```

**Code**

```c
unsigned char x = 5; // 0000 0101
printf("x<<1 = %u\n", (unsigned)(x << 1)); // 0000 1010 -> 10
printf("x<<2 = %u\n", (unsigned)(x << 2)); // 0001 0100 -> 20
```

---

## 6) Right Shift `>>` — shift right; fill with 0s for unsigned (≈ divide by 2)

**Binary idea**

```
y     = 0001 0100 (20)
y>>1  = 0000 1010 (10)
y>>2  = 0000 0101 (5)
```

**Code**

```c
unsigned char y = 20; // 0001 0100
printf("y>>1 = %u\n", (unsigned)(y >> 1)); // 0000 1010 -> 10
printf("y>>2 = %u\n", (unsigned)(y >> 2)); // 0000 0101 -> 5
```

> Prefer **unsigned** for predictable shifts. Right‑shifting negative signed values can be implementation‑defined.

---

# Applications (with binary first, then code)

## A) Check Even/Odd (look at the **last bit**)

**Binary idea**

```
Odd numbers end with ...1
Even numbers end with ...0

x & 1
- if last bit is 1 -> odd
- if last bit is 0 -> even
```

**Code**

```c
#include <stdio.h>
int main() {
    unsigned char x;

    x = 13; // 0000 1101 -> last bit 1 -> odd
    printf("%u is %s\n", x, (x & 1) ? "Odd" : "Even");

    x = 14; // 0000 1110 -> last bit 0 -> even
    printf("%u is %s\n", x, (x & 1) ? "Odd" : "Even");
    return 0;
}
```

**Output**

```
13 is Odd
14 is Even
```

---

## B) Swap two numbers (XOR trick)

**Binary idea (concept)**
XORing with the same value twice cancels out:

```
a ^= b
b ^= a   // now b = old a
a ^= b   // now a = old b
```

**Code**

```c
int a = 10, b = 20;  // (binary not shown fully here; concept is key)
a ^= b;  // mix bits
b ^= a;  // extract original a
a ^= b;  // extract original b
printf("a=%d b=%d\n", a, b); // a=20 b=10
```

(For production, a temp variable is clearer; XOR swap is great for understanding XOR.)

---

## C) Track attendance (8 days in 1 byte)

* **Bit = day** (`bit 0` = Day1, `bit 1` = Day2, …)
* `1` = present, `0` = absent

### Steps (binary first)

1. Start all 0:

```
att = 0000 0000
```

2. Mark Day1 present → set bit‑0:

```
att | (1<<0)
0000 0000
0000 0001
---------
0000 0001
```

3. Mark Day4 present → set bit‑3:

```
0000 0001
0000 1000
---------
0000 1001
```

4. Clear Day1 → clear bit‑0:

```
0000 1001
1111 1110   (~(1<<0))
---------
0000 1000
```

5. Toggle Day2 → flip bit‑1:

```
0000 1000
0000 0010   (1<<1)
---------
0000 1010   (XOR)
```

**Code (mirrors the steps)**

```c
#include <stdio.h>

int main() {
    unsigned char att = 0;                 // 0000 0000

    att = att | (1u << 0);                 // set day1 -> 0000 0001
    att = att | (1u << 3);                 // set day4 -> 0000 1001
    att = att & ~(1u << 0);                // clear day1 -> 0000 1000
    att = att ^ (1u << 1);                 // toggle day2 -> 0000 1010

    // Check day4 (bit-3)
    if (att & (1u << 3)) printf("Day4: Present\n"); // 1 at bit-3
    else                 printf("Day4: Absent\n");

    // Show final decimal mask (0000 1010 = 10)
    printf("Attendance mask = %u\n", att);
    return 0;
}
```

**Output**

```
Day4: Present
Attendance mask = 10
```

---

Perfect, let’s continue that **bit-manipulation cheatsheet** with full binary breakdown, **step-by-step**, so students clearly see how `set`, `clear`, `toggle` actually affect the bits.

---
