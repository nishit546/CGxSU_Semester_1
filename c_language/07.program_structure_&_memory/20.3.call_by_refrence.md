# 20.3: Call‑by‑Reference in C (using Pointers)

In C, **everything is passed by value**—even pointers.
But if you **pass the address** of something (a pointer), the function can use that address to **modify the original data**. This pattern is called **call‑by‑reference**.

Think: instead of giving someone a **photocopy** (value), you hand them the **address of your locker** (pointer). Now they can change what’s inside.

---

## 1) Warm‑up: Why call‑by‑reference?

### Call‑by‑value (can’t change caller’s variable)

```c
#include <stdio.h>

void bump_value(int x) {   // gets a copy
    x = x + 1;             // modifies only the copy
}

int main() {
    int n = 10;
    bump_value(n);
    printf("n = %d\n", n); // 10 (unchanged)
    return 0;
}
```

### Call‑by‑reference with a pointer (can change it)

```c
#include <stdio.h>

void bump_ref(int *px) {   // gets address of n
    *px = *px + 1;         // write into original n
}

int main() {
    int n = 10;
    bump_ref(&n);          // pass address
    printf("n = %d\n", n); // 11 (changed)
    return 0;
}
```

**Key idea**

* `&n` → address of `n`
* `px` → receives that address
* `*px` → “go to that address” (dereference) and modify the real `n`

---

## 2) Classic example: `swap` two numbers

### ❌ Fails with call‑by‑value

```c
#include <stdio.h>

void swap_bad(int a, int b) { // copies only
    int t = a; a = b; b = t;
}

int main() {
    int x = 3, y = 7;
    swap_bad(x, y);
    printf("x=%d y=%d\n", x, y); // x=3 y=7 (unchanged)
    return 0;
}
```

### ✅ Works with call‑by‑reference

```c
#include <stdio.h>

void swap(int *pa, int *pb) {
    // Iteration trace:
    // *pa refers to x, *pb refers to y
    int t = *pa;         // t = x
    *pa = *pb;           // x = y
    *pb = t;             // y = t (old x)
}

int main() {
    int x = 3, y = 7;
    swap(&x, &y);
    printf("x=%d y=%d\n", x, y); // x=7 y=3
    return 0;
}
```

---

## 3) Modify array elements in a function

When you pass an **array** to a function, it **decays to a pointer** to its first element—so modifications affect the original array.

```c
#include <stdio.h>

void add_bonus(int a[], int n, int bonus) {
    // a is like int *a
    for (int i = 0; i < n; i++) {
        // Iteration:
        // i=0: a[0]+=bonus, i=1: a[1]+=bonus, ...
        a[i] += bonus;
    }
}

int main() {
    int marks[5] = {70, 72, 68, 90, 85};
    add_bonus(marks, 5, 5);
    for (int i = 0; i < 5; i++) printf("%d ", marks[i]);
    // 75 77 73 95 90
    return 0;
}
```

---

## 4) Update a string (character array) in a function

```c
#include <stdio.h>

void to_upper(char s[]) {          // char *s
    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] >= 'a' && s[i] <= 'z')
            s[i] = s[i] - 'a' + 'A';
    }
}

int main() {
    char name[] = "codinggita";
    to_upper(name);
    printf("%s\n", name);          // CODINGGITA
    return 0;
}
```

> ⚠️ Don’t do this with **string literals** (`char *p = "text";`)—they’re typically read‑only. Always pass a **mutable char array**.

---

## 5) “Return” multiple results via output parameters

Functions in C can only **return one value**—but with pointers, you can **fill several outputs**.

```c
#include <stdio.h>

void stats(const int *a, int n, int *pmin, int *pmax, double *pavg) {
    int mn = a[0], mx = a[0];
    long long sum = 0;

    for (int i = 0; i < n; i++) {
        if (a[i] < mn) mn = a[i];
        if (a[i] > mx) mx = a[i];
        sum += a[i];
    }
    *pmin = mn;                  // write results to caller's vars
    *pmax = mx;
    *pavg = (double)sum / n;
}

int main() {
    int marks[] = {81, 76, 90, 68, 92};
    int minv, maxv; double avg;
    stats(marks, 5, &minv, &maxv, &avg);
    printf("min=%d max=%d avg=%.2f\n", minv, maxv, avg);
    // min=68 max=92 avg=81.40
    return 0;
}
```

---

## 6) Pointers + `const` (read‑only promises)

Use `const` to **express intent** and prevent accidental writes.

```c
void print_array(const int *a, int n) { // won't modify elements
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
}

// const positions:
// const int *p   → pointer to const int (data read‑only, pointer can change)
// int *const p   → const pointer to int (pointer fixed, data modifiable)
// const int *const p → both pointer and data treated as read‑only here
```

This helps create safer APIs for your modules.

---

## 7) Pointer to pointer: when the callee must change a pointer itself

If a function must **repoint** a caller’s pointer (e.g., set it to `NULL`, or make it point to a different array), pass a **pointer to pointer**.

```c
#include <stdio.h>

void zero_out(int **pp) {
    // make caller's pointer NULL
    *pp = NULL;
}

int main() {
    int x = 42;
    int *p = &x;
    zero_out(&p);                   // pass address of pointer p
    printf("p is %s\n", p == NULL ? "NULL" : "not NULL"); // NULL
    return 0;
}
```

> You’ll use this pattern more in Data Structures (e.g., changing head of a linked list).

---

## 8) Common pitfalls (and fixes)

1. **Forgetting to pass address**

```c
void inc(int *p) { (*p)++; }
int x = 10;
// inc(x);          // ❌ passing value, not address
inc(&x);             // ✅
```

2. **Dereferencing a NULL / uninitialized pointer**

```c
int *p = NULL;
// *p = 5;         // ❌ crash; ensure p points to valid memory first
```

3. **Confusing value vs address vs dereference in prints**

```c
printf("%d",  x);        // value
printf("%p", (void*)&x); // address of x
printf("%p", (void*)p);  // pointer value (address)
printf("%d", *p);        // value pointed to by p
```

4. **Array size vs pointer size**

```c
int a[5];
int *p = a;
printf("%zu\n", sizeof(a)); // 20 on 32-bit int
printf("%zu\n", sizeof(p)); // 8 (pointer on 64-bit)
```

---

## 9) Mini “CodingGita” examples

### A) Bump all semester marks by +2 (in place)

```c
#include <stdio.h>

void curve(int *a, int n, int add) {
    for (int i = 0; i < n; i++) a[i] += add;
}

int main() {
    int marks[] = {39, 55, 67, 74};
    curve(marks, 4, 2);   // pass array (pointer)
    for (int i = 0; i < 4; i++) printf("%d ", marks[i]); // 41 57 69 76
    return 0;
}
```

### B) Sanitize username: convert spaces to underscores

```c
#include <stdio.h>

void spaces_to_underscores(char *s) {
    for (int i = 0; s[i] != '\0'; i++)
        if (s[i] == ' ') s[i] = '_';
}

int main() {
    char user[] = "coding gita student";
    spaces_to_underscores(user);
    printf("%s\n", user); // coding_gita_student
    return 0;
}
```

---

## 10) Quick checklist

* Pass **addresses** (`&var`) to let functions modify caller’s variables.
* Inside, accept **pointers** and dereference (`*p`) to read/write.
* Arrays naturally behave “by reference” (decay to pointer).
* Use **`const`** on pointer parameters when you won’t modify data.
* For changing a **pointer itself**, use **pointer to pointer**.
* Watch out for NULL and uninitialized pointers.

---
