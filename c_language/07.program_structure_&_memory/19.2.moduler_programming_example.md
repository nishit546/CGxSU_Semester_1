# 19.2: Modular Programming & Header Files — Demo

Goal: take one tiny feature, split it into **`.h` + `.c` + `main.c`**, compile cleanly, and see how **prototypes + include guards** make reuse easy.

We’ll build a mini module **`cg_math`** for CodingGita with two functions:

* `int add(int a, int b)`
* `int max2(int a, int b)`

---

## 1) Project layout

Create a folder (say `cg-mod-demo/`) with **three files**:

```
cg-mod-demo/
├── cg_math.h    // header: declarations (what exists)
├── cg_math.c    // source: definitions  (how it works)
└── main.c       // uses the module
```

---

## 2) Write the header — `cg_math.h`

* Put **function prototypes** here.
* Add an **include guard** so multiple inclusions don’t break the build.

```c
// cg_math.h
#ifndef CG_MATH_H      // begin include guard
#define CG_MATH_H

// Function prototypes (declarations)
int add(int a, int b);
int max2(int a, int b);

#endif // CG_MATH_H     // end include guard
```

Why this matters:

* Prototypes tell the compiler **“these functions exist somewhere”**.
* The guard prevents duplicate declarations when the header is included from multiple files.

---

## 3) Write the implementation — `cg_math.c`

* Include **its own header** to keep prototypes and definitions in sync.

```c
// cg_math.c
#include "cg_math.h"

int add(int a, int b) {
    return a + b;
}

int max2(int a, int b) {
    return (a > b) ? a : b;
}
```

Note: If you change a function signature here, the compiler will warn if the header doesn’t match (because we included it).

---

## 4) Write the program that uses the module — `main.c`

* Include the **standard I/O** and **our header**.
* Call the functions just like you’d call `printf`.

```c
// main.c
#include <stdio.h>
#include "cg_math.h"   // quotes for your own headers

int main(void) {
    int a = 12, b = 7;

    // Using functions declared in cg_math.h and defined in cg_math.c
    int s = add(a, b);
    int m = max2(a, b);

    printf("[CodingGita] add(%d, %d) = %d\n", a, b, s);
    printf("[CodingGita] max2(%d, %d) = %d\n", a, b, m);

    return 0;
}
```

**Expected output**

```
[CodingGita] add(12, 7) = 19
[CodingGita] max2(12, 7) = 12
```

---

## 5) Compile & run

### Option A: One‑shot compile

```bash
gcc main.c cg_math.c -o app
./app
```

### Option B: Two‑step (shows real workflow: compile → link)

```bash
# Compile each .c into an object file
gcc -c main.c      # creates main.o
gcc -c cg_math.c   # creates cg_math.o

# Link objects into final executable
gcc main.o cg_math.o -o app

# Run
./app
```

Why two steps matter:

* In larger projects, you only recompile the files that changed, then **link** everything quickly.

---

## 6) Quick proof: include guards work

Try adding **two includes** in `main.c`:

```c
#include "cg_math.h"
#include "cg_math.h"  // (duplicate on purpose)
```

It still compiles because the guard in `cg_math.h` allows it safely.

---

## 7) What if we **forget** the header?

Comment out the `#include "cg_math.h"` in `main.c` and try compiling:

```c
// #include "cg_math.h"

int main(void) {
    int s = add(2, 3);   // compiler doesn't know add()
    ...
}
```

You’ll get an error like:

```
implicit declaration of function ‘add’
```

**Lesson:** Always include the header that declares the functions you use.

---

## 8) Extend the module (reusability in action)

Add one more function to the **header** and **source** only—`cg_math.h` & `cg_math.c`—and use it immediately in `main.c`.

### In `cg_math.h`

```c
int clamp(int x, int lo, int hi);  // keep x in [lo, hi]
```

### In `cg_math.c`

```c
int clamp(int x, int lo, int hi) {
    if (x < lo) return lo;
    if (x > hi) return hi;
    return x;
}
```

### In `main.c`

```c
int c = clamp(105, 0, 100);
printf("[CodingGita] clamp(105, 0, 100) = %d\n", c); // 100
```

Rebuild:

```bash
gcc main.c cg_math.c -o app
./app
```

You didn’t touch the logic in `main.c` beyond the new call; the module grows cleanly.

---

## 9) Recap

* **`.h` header** = *what exists*: prototypes, constants, typedefs, macros.
* **`.c` source**  = *how it works*: function definitions.
* **`main.c`** uses the module via `#include "your_header.h"`.
* Compile all `.c` files together (or to `.o` then link).
* Always use **include guards** in headers.

