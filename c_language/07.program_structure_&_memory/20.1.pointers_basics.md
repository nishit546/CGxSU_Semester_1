# 20.1: Pointers Basics in C

Pointers are one of the most **powerful concepts in C**, but also one of the most confusing for beginners. Think of a pointer as a **house address**:

* A variable is the **house** (where data lives).
* A pointer is the **address of that house** (where to find it).

Let’s break it down.

---

## 1) What is a Pointer?

* A **pointer** is a variable that stores the **memory address** of another variable.
* To declare a pointer, we use `*`:

```c
int *p;  // pointer to int
char *c; // pointer to char
float *f; // pointer to float
```

👉 The `*` means “pointer to …”.

---

## 2) Address-of (`&`) and Dereference (`*`) Operators

* **`&`** → gives the **address** of a variable.
* **`*`** → goes to that address and gets the **value** (dereference).

---

## 3) Example: Variable, Address, Pointer, Dereference

```c
#include <stdio.h>
int main() {
    int x = 42;       // normal variable
    int *p = &x;      // pointer stores address of x

    printf("x = %d\n", x);        // prints value of x
    printf("&x = %p\n", (void*)&x); // prints address of x
    printf("p = %p\n", (void*)p);   // pointer holds same address
    printf("*p = %d\n", *p);      // dereference → value at address

    return 0;
}
```

### Sample Output

```
x = 42
&x = 0x7ffeef3c9a4c   <-- address of x (changes every run)
p = 0x7ffeef3c9a4c    <-- pointer stores same address
*p = 42               <-- value at that address
```

👉 So `*p` is the **value inside x**, while `p` is the **address of x**.

---

## 4) Updating Values via Pointer

```c
#include <stdio.h>
int main() {
    int x = 10;
    int *p = &x;

    printf("Before: x = %d\n", x);

    *p = 50;   // change value at address → modifies x

    printf("After: x = %d\n", x);
    return 0;
}
```

### Output

```
Before: x = 10
After: x = 50
```

👉 Changing `*p` actually changed `x`.
This is the **foundation** of “call by reference” in functions (covered later).

---

## 5) Pointer Size

```c
#include <stdio.h>
int main() {
    int *pi;
    char *pc;
    double *pd;

    printf("Size of int* = %zu\n", sizeof(pi));
    printf("Size of char* = %zu\n", sizeof(pc));
    printf("Size of double* = %zu\n", sizeof(pd));

    return 0;
}
```

### Example Output (on 64-bit system)

```
Size of int* = 8
Size of char* = 8
Size of double* = 8
```

👉 No matter the data type, a pointer just stores an **address**. On most 64-bit systems, that takes **8 bytes**.

---

## 6) Common Mistakes with Pointers

### A) Uninitialized Pointer (Wild Pointer)

```c
int *p;   // ❌ uninitialized
*p = 100; // ERROR: writing to random memory
```

**Fix**: Always initialize (`int *p = NULL;` or assign a valid address).

---

### B) Wrong Type of Pointer

```c
int x = 65;
int *pi = &x;
char *pc = (char*)&x;   // force cast

printf("*pi = %d\n", *pi); // reads as int → 65
printf("*pc = %c\n", *pc); // reads first byte as char → 'A'
```

👉 Same memory, but type changes how it’s interpreted.

---

### C) Forgetting Dereference

```c
int x = 10;
int *p = &x;

printf("%p\n", p);   // prints address
printf("%d\n", *p);  // prints value
```

👉 Beginners often confuse printing `p` (address) vs `*p` (value).

---

## 7) Recap

* **Pointer = variable that stores an address**.
* **`&`** gives address, **`*`** dereferences.
* You can change a variable indirectly via its pointer.
* Pointers have a fixed size (usually 8 bytes on 64-bit).
* Beware of **wild pointers** and type mismatches.

---

## 8) Mini Practice

1. Declare an `int x = 99;` and a pointer to it. Print:

   * `x`, `&x`, `p`, and `*p`.
2. Change `x` via pointer (`*p = 200;`). Print `x`.
3. What happens if you dereference an uninitialized pointer? Try with `int *p; printf("%d", *p);`.
4. Using a `char *`, print the first byte of an integer (see ASCII effect).

---
