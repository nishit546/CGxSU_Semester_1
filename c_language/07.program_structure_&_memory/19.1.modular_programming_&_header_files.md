# 19.1 Modular Programming & Header Files in C

## 1) What is Modular Programming?

* **Modular programming** = breaking a program into **smaller independent units** (modules).
* Each module has **specific functionality** (e.g., math utilities, string utilities, file handling).
* Modules make code:

  * Easier to **understand** (smaller chunks)
  * Easier to **reuse** (use in multiple projects)
  * Easier to **debug/maintain**

Think of a **school system**:

* **Teachers module**: store teacher info
* **Students module**: handle student data
* **Library module**: manage books

Each works independently, but together they form the full system.

---

## 2) Splitting Code into `.h` and `.c` Files

In modular programming:

* **Header file (`.h`)** → contains **function prototypes, macros, constants, and type definitions**.
* **Implementation file (`.c`)** → contains **actual function definitions (code)**.
* **Main program (`main.c`)** → uses these modules by **including the header**.

---

### Example: Math Utility Module

#### Step 1: `mathutils.h` (Header File)

```c
// mathutils.h
#ifndef MATHUTILS_H    // include guard (avoids double inclusion)
#define MATHUTILS_H

// Function prototypes
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);

#endif
```

#### Step 2: `mathutils.c` (Implementation File)

```c
// mathutils.c
#include "mathutils.h"   // include its own header

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}
```

#### Step 3: `main.c` (Using the Module)

```c
#include <stdio.h>
#include "mathutils.h"   // include custom header

int main() {
    int x = 10, y = 5;

    printf("Add = %d\n", add(x, y));
    printf("Subtract = %d\n", subtract(x, y));
    printf("Multiply = %d\n", multiply(x, y));

    return 0;
}
```

---

## 3) Compiling Multiple Files

When you split into `.c` files, you must **compile them together**:

```bash
gcc main.c mathutils.c -o program
./program
```

**Output**

```
Add = 15
Subtract = 5
Multiply = 50
```

---

## 4) Function Prototypes (Why Header Files Exist)

* The compiler must **know about a function before it’s used**.
* If `main.c` calls `add()`, it must **see the prototype** (`int add(int,int);`) first.
* That’s why we put **prototypes in `.h`** — so multiple `.c` files can include it without duplicating code.

---

### Without prototype (wrong):

```c
#include <stdio.h>

int main() {
    printf("%d\n", add(5, 3));   // ❌ Compiler doesn’t know "add"
    return 0;
}
```

Error:

```
implicit declaration of function ‘add’
```

---

### With prototype (correct):

```c
#include <stdio.h>

// Prototype
int add(int a, int b);

int main() {
    printf("%d\n", add(5, 3));   // ✅ OK
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

---

## 5) Benefits of Modular Programming

1. **Code Reusability**

   * Write once, use anywhere.
   * Example: `mathutils.h/.c` can be reused in many projects.

2. **Team Collaboration**

   * Different team members can work on different `.c` files.

3. **Maintainability**

   * Bugs are easier to isolate and fix inside small modules.

4. **Scalability**

   * Large systems (like operating systems, compilers) are impossible in a single file.

---

## 6) Real-World Analogy

Think of **Netflix**:

* **Video module** → play/pause/stop
* **User module** → login, profile
* **Payment module** → billing

Each is separate, but combined they create the app.

---

## 7) Common Pitfalls

1. **Forgetting include guards** (`#ifndef/#define/#endif`) → causes duplicate definition errors.
2. **Declaring functions in `.c` only** → can’t use across files.
3. **Mixing `.h` and `.c` roles** → remember:

   * `.h` = *what* (prototypes, declarations)
   * `.c` = *how* (definitions, actual code)

---

## 8) Quick Practice for You

1. Create a module `stringutils.h/.c` with functions:

   * `reverseString()`
   * `toUpperCase()`
2. Use them in `main.c` to process a user’s name.

---
