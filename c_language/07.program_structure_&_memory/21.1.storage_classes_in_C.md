# 21: Storage Classes in C

In C, **storage classes** define four critical aspects of a variable:

1. **Scope** â€“ where the variable can be accessed (block, file, etc.)
2. **Lifetime** â€“ how long the variable exists in memory
3. **Default initial value** â€“ what it holds if not initialized
4. **Storage location** â€“ stack, heap, or CPU register

The four storage classes are:

* `auto`
* `register`
* `static`
* `extern`

---

## 1) `auto` â€“ Automatic Storage Class

* **Default** for all **local variables** inside a function/block.
* Stored in **stack memory**.
* Scope: **block**.
* Lifetime: created when block starts, destroyed when block ends.
* Default value: **garbage**.

```c
#include <stdio.h>
int main() {
    auto int x = 10;  // 'auto' is optional
    int y = 20;       // same as 'auto'
    printf("x=%d y=%d\n", x, y);
    return 0;
}
```

**Output**

```
x=10 y=20
```

ðŸ‘‰ Normally, you **donâ€™t write `auto`**, since itâ€™s the default.

---

## 2) `register` â€“ Fast Access Variables

* Suggests compiler to store variable in a **CPU register** instead of RAM.
* Faster access for frequently used variables (e.g., loop counters).
* Scope: block.
* Lifetime: block duration.
* Default value: garbage.
* **Cannot take the address (`&`)** of a register variable (since it may not be in RAM).

```c
#include <stdio.h>
int main() {
    register int i;
    for (i = 1; i <= 5; i++) {
        printf("%d ", i);
    }
    return 0;
}
```

**Output**

```
1 2 3 4 5
```

ðŸ‘‰ The compiler **may ignore** `register` if no CPU register is free.

---

## 3) `static` â€“ Persistent Variables

* Scope: block (if declared inside a function).
* Lifetime: entire program (retains value between function calls).
* Default value: `0`.
* Stored in **data segment** (not stack).

### Example A: Static local variable

```c
#include <stdio.h>
void counter() {
    static int count = 0;  // initialized only once
    count++;
    printf("count = %d\n", count);
}
int main() {
    counter(); // count=1
    counter(); // count=2
    counter(); // count=3
    return 0;
}
```

**Output**

```
count = 1
count = 2
count = 3
```

ðŸ‘‰ Unlike normal `auto` variables, static variables **remember values** across calls.

### Example B: Static global variable

```c
static int g = 10;  // file scope, but not visible to other .c files
```

* Makes a global variable **private** to its file (hidden from other files).

---

## 4) `extern` â€“ External Variables

* Declares a variable defined in **another file**.
* Scope: global.
* Lifetime: entire program.
* Default value: 0.

### Example across two files

**file1.c**

```c
#include <stdio.h>
int global = 42;  // defined here

void show() {
    printf("Global in file1.c = %d\n", global);
}
```

**file2.c**

```c
#include <stdio.h>
extern int global;   // declare, not define

int main() {
    printf("Global in file2.c = %d\n", global);
    return 0;
}
```

ðŸ‘‰ When you **compile both files together**, both use the same global variable.

---

## 5) Summary Table

| Storage Class | Scope              | Lifetime        | Default Value | Storage  |
| ------------- | ------------------ | --------------- | ------------- | -------- |
| `auto`        | Local block        | Block execution | Garbage       | Stack    |
| `register`    | Local block        | Block execution | Garbage       | CPU reg  |
| `static`      | Local block        | Entire program  | 0             | Data seg |
| `extern`      | Global (all files) | Entire program  | 0             | Data seg |

---

## 6) Key Takeaways

* Use **`auto`** (default) for normal local variables.
* Use **`register`** for frequently accessed variables in loops.
* Use **`static`** when you want variables to **persist** across function calls.
* Use **`extern`** to share global variables across files.

---
