# 20.2: Pointers with Variables & Arrays

In the last article, we saw that a pointer stores the **address** of a variable.
Now let’s see how pointers are **closely linked with arrays** in C.

---

## 1) Pointers with Normal Variables

Recall:

```c
#include <stdio.h>
int main() {
    int x = 42;
    int *p = &x; // p stores address of x

    printf("x = %d\n", x);     // value
    printf("&x = %p\n", (void*)&x); // address of x
    printf("p = %p\n", (void*)p);   // same address
    printf("*p = %d\n", *p);   // value at that address
    return 0;
}
```

**Output (example)**

```
x = 42
&x = 0x7ffee6f9b2a4
p = 0x7ffee6f9b2a4
*p = 42
```

👉 A pointer to a variable lets us access the same value indirectly.

---

## 2) Array Name as a Pointer

In C, the name of an array (e.g., `arr`) **decays** into a pointer to its **first element** (`&arr[0]`).

```c
#include <stdio.h>
int main() {
    int arr[3] = {10, 20, 30};

    printf("arr = %p\n", (void*)arr);      // address of arr[0]
    printf("&arr[0] = %p\n", (void*)&arr[0]);
    printf("&arr[1] = %p\n", (void*)&arr[1]);
    printf("&arr[2] = %p\n", (void*)&arr[2]);

    return 0;
}
```

**Output (example, addresses differ each run)**

```
arr = 0x7ffdbf4a3e00
&arr[0] = 0x7ffdbf4a3e00
&arr[1] = 0x7ffdbf4a3e04
&arr[2] = 0x7ffdbf4a3e08
```

👉 Notice:

* `arr == &arr[0]`
* Each `int` took **4 bytes** (address difference).

---

## 3) Accessing Array Elements Using Pointers

```c
#include <stdio.h>
int main() {
    int arr[3] = {10, 20, 30};
    int *p = arr; // same as &arr[0]

    // Access with pointer
    printf("*p = %d\n", *p);       // 10
    printf("*(p+1) = %d\n", *(p+1)); // 20
    printf("*(p+2) = %d\n", *(p+2)); // 30

    return 0;
}
```

**Output**

```
*p = 10
*(p+1) = 20
*(p+2) = 30
```

👉 So `p+1` doesn’t mean “add 1 byte” → it means “go to the **next int**” (i.e., +4 bytes here).
This is called **pointer arithmetic**.

---

## 4) Iterating Over Array with Pointer

```c
#include <stdio.h>
int main() {
    int arr[5] = {5, 10, 15, 20, 25};
    int *p = arr;

    for (int i = 0; i < 5; i++) {
        // Iteration trace:
        // i=0 → *(p+0)=5
        // i=1 → *(p+1)=10
        // ...
        printf("arr[%d] = %d (via pointer)\n", i, *(p+i));
    }
    return 0;
}
```

**Output**

```
arr[0] = 5 (via pointer)
arr[1] = 10 (via pointer)
arr[2] = 15 (via pointer)
arr[3] = 20 (via pointer)
arr[4] = 25 (via pointer)
```

👉 `arr[i]` and `*(arr+i)` are **100% equivalent**.

---

## 5) Modifying Array Elements with Pointer

```c
#include <stdio.h>
int main() {
    int arr[3] = {1, 2, 3};
    int *p = arr;

    *p = 10;       // arr[0] = 10
    *(p+1) = 20;   // arr[1] = 20
    *(p+2) = 30;   // arr[2] = 30

    for (int i = 0; i < 3; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```

**Output**

```
10 20 30
```

👉 Pointers let you directly **edit array contents**.

---

## 6) Pointer Arithmetic (Important)

### Example

```c
#include <stdio.h>
int main() {
    int arr[3] = {100, 200, 300};
    int *p = arr;

    printf("p = %p\n", (void*)p);
    printf("p+1 = %p\n", (void*)(p+1));
    printf("p+2 = %p\n", (void*)(p+2));

    return 0;
}
```

**Output (addresses differ)**

```
p = 0x7ffd40ab3e10
p+1 = 0x7ffd40ab3e14
p+2 = 0x7ffd40ab3e18
```

👉 For `int` (4 bytes), `p+1` jumps **4 bytes** ahead.

---

## 7) Common Mistakes

### A) Going Out of Bounds

```c
int arr[3] = {1,2,3};
int *p = arr;
printf("%d\n", *(p+3));  // ❌ undefined behavior
```

### B) Pointer vs Array Size Confusion

```c
int arr[5] = {1,2,3,4,5};
int *p = arr;

printf("sizeof(arr) = %zu\n", sizeof(arr)); // 20 bytes (5 ints)
printf("sizeof(p) = %zu\n", sizeof(p));     // 8 bytes (pointer)
```

👉 Array **size in bytes** vs pointer **size in bytes** (different things!).

---

## 8) Mini Practice

1. Use a pointer to print the array `{2,4,6,8,10}`.
2. Write code to find the **maximum element** of an array using pointers.
3. Modify all array elements by multiplying them by 2 using a pointer.
4. Print array addresses (`&arr[i]`) using `p+i`.

---

## Recap

* Array name (`arr`) = pointer to its first element (`&arr[0]`).
* `arr[i]` == `*(arr+i)`.
* Pointer arithmetic moves by **element size**, not 1 byte.
* Don’t confuse `sizeof(arr)` (whole array) with `sizeof(pointer)`.
* Pointers allow iterating and modifying arrays efficiently.

---
