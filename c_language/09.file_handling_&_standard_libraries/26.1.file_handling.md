# 26: File Handling in C (Text Files)

You’ll use files for everything—from saving **CodingGita** student data to logging app events. In C, file I/O is done with the **stdio** library using a `FILE*` handle.

This article covers:

* `fopen`, `fclose`, `fprintf`, `fscanf`
* Reading & writing **text** files safely
* Proper error handling with `NULL`, `feof`, `ferror`
* Realistic, commented examples + sample outputs

---

## 1) Opening & closing files

```c
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
```

**Common modes (text files):**

* `"r"`  → read (must exist)
* `"w"`  → write (create or **truncate** existing)
* `"a"`  → append (create if not exists)
* `"r+"` → read/write (must exist, no truncate)
* `"w+"` → read/write (create or truncate)
* `"a+"` → read/append (create if not exists; reads from start, writes at end)

**Always check for `NULL`:**

```c
FILE *fp = fopen("students.txt", "r");
if (!fp) {
    perror("fopen failed");  // prints system reason (e.g., No such file or directory)
    return 1;
}
fclose(fp);
```

---

## 2) Writing text: `fprintf`

`fprintf(fp, "...", values...)` works like `printf` but writes to a file.

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("cg_students.txt", "w");  // overwrites if exists
    if (!fp) { perror("open"); return 1; }

    // Write a header + 3 student rows: roll name marks
    fprintf(fp, "ROLL NAME MARKS\n");
    fprintf(fp, "%d %s %.2f\n", 101, "Neel",   85.50);
    fprintf(fp, "%d %s %.2f\n", 102, "Yashvi", 90.00);
    fprintf(fp, "%d %s %.2f\n", 103, "Mahir",  78.25);

    if (fclose(fp) != 0) perror("close");
    return 0;
}
```

**Creates `cg_students.txt`:**

```
ROLL NAME MARKS
101 Neel 85.50
102 Yashvi 90.00
103 Mahir 78.25
```

> Tip: Use `"a"` mode to **append** more rows later without overwriting.

---

## 3) Reading text: `fscanf` (fixed format)

`fscanf` returns the **number of items successfully read**. Always check it.

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("cg_students.txt", "r");
    if (!fp) { perror("open"); return 1; }

    char header1[8], header2[8], header3[8];
    if (fscanf(fp, "%7s %7s %7s", header1, header2, header3) != 3) {
        fprintf(stderr, "Bad header\n");
        fclose(fp);
        return 1;
    }

    int roll;
    char name[32];
    float marks;

    // Correct pattern: loop while fscanf succeeds
    while (fscanf(fp, "%d %31s %f", &roll, name, &marks) == 3) {
        printf("ROLL=%d NAME=%s MARKS=%.2f\n", roll, name, marks);
    }

    if (ferror(fp)) perror("read error"); // I/O error during read
    fclose(fp);
    return 0;
}
```

**Sample output:**

```
ROLL=101 NAME=Neel MARKS=85.50
ROLL=102 NAME=Yashvi MARKS=90.00
ROLL=103 NAME=Mahir MARKS=78.25
```

> ✅ **Do this**: check the return value of `fscanf`.
> ❌ **Don’t do this**: `while(!feof(fp)) { fscanf(...); }` (classic bug).

---

## 4) Reading lines safely: `fgets` (+ parsing)

`fscanf("%s", ...)` stops at spaces. For names like “Mahir Patel”, use `fgets` + parsing.

```c
#include <stdio.h>
#include <string.h>

int main() {
    FILE *fp = fopen("names.txt", "w");
    if (!fp) { perror("open"); return 1; }
    fprintf(fp, "101,Neel,85.5\n");
    fprintf(fp, "102,\"Mahir Patel\",90.0\n");  // CSV-like with quotes
    fprintf(fp, "103,Krishna,78.0\n");
    fclose(fp);

    fp = fopen("names.txt", "r");
    if (!fp) { perror("open"); return 1; }

    char line[128];
    while (fgets(line, sizeof line, fp)) {
        // remove trailing newline if present
        line[strcspn(line, "\r\n")] = '\0';
        printf("LINE: %s\n", line);
        // Simple split demo (NOT a full CSV parser)
        // For now, just print the line as-is for beginners
    }

    if (ferror(fp)) perror("read error");
    fclose(fp);
    return 0;
}
```

> Use `fgets` when the input can contain **spaces**. For serious CSV parsing, you’d tokenize the line (e.g., `strtok`) and handle quotes.

---

## 5) Append mode example: logging

```c
#include <stdio.h>
#include <time.h>

int main() {
    FILE *log = fopen("cg_log.txt", "a");
    if (!log) { perror("open"); return 1; }

    time_t now = time(NULL);
    fprintf(log, "Login at %ld (epoch)\n", (long)now);

    fclose(log);
    return 0;
}
```

Run multiple times → lines keep **adding**.

---

## 6) Error handling patterns (must know)

### 6.1 Check `fopen` result

```c
FILE *fp = fopen("missing.txt", "r");
if (!fp) { perror("fopen"); /* handle / return */ }
```

### 6.2 Detect read/write problems

* `ferror(fp)` → non-zero if an I/O error occurred.
* `feof(fp)`   → non-zero **after** you attempt to read **past** end of file.

**Correct loop pattern:**

```c
int roll; char name[32]; float marks;
while (fscanf(fp, "%d %31s %f", &roll, name, &marks) == 3) {
    /* process */
}
if (ferror(fp)) { perror("I/O error"); }
else if (feof(fp)) { /* reached end normally */ }
```

**Why not `while (!feof(fp))`?**
Because `feof` is set **only after** you try to read past the end. You’ll process a bogus “last read”.

---

## 7) Overwrite vs Append vs Read/Write

* `"w"` / `"w+"` → **truncate** file first (start fresh).
* `"a"` / `"a+"` → preserves existing data; writes go to the end.
* `"r+"`         → read & modify existing file without truncating.

**Mini demo (don’t run on important files):**

```c
FILE *fp = fopen("demo.txt", "w");  // create fresh
fprintf(fp, "Hello\n");
fclose(fp);

fp = fopen("demo.txt", "a");        // append
fprintf(fp, "World\n");
fclose(fp);

fp = fopen("demo.txt", "r");        // read
char buf[64];
while (fgets(buf, sizeof buf, fp)) printf("%s", buf);
fclose(fp);
/* File now:
Hello
World
*/
```

---

## 8) Safer string reads with `fscanf`

If you *must* use `fscanf` for strings with spaces, use a scanset:

```c
// read until newline into name (keep one spot for '\0')
if (fscanf(fp, "%d %119[^\n]", &roll, name) == 2) { /* ok */ }
```

But for beginners, `fgets` + parsing is usually clearer & safer.

---

## 9) A tiny “Student Record” demo (write → read)

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    int   roll;
    char  name[32];
    float marks;
} Student;

int main() {
    // 1) Write records (truncate/replace file)
    {
        FILE *wp = fopen("students.txt", "w");
        if (!wp) { perror("write open"); return 1; }

        Student s[] = {
            {101, "Neel",   85.5f},
            {102, "Mahir",  90.0f},
            {103, "Yashvi", 78.0f}
        };

        for (int i = 0; i < 3; i++) {
            // space‑separated, simple to parse
            fprintf(wp, "%d %s %.2f\n", s[i].roll, s[i].name, s[i].marks);
        }
        fclose(wp);
    }

    // 2) Read records back
    {
        FILE *rp = fopen("students.txt", "r");
        if (!rp) { perror("read open"); return 1; }

        int roll; char name[32]; float marks;
        while (fscanf(rp, "%d %31s %f", &roll, name, &marks) == 3) {
            printf("ROLL=%d NAME=%s MARKS=%.2f\n", roll, name, marks);
        }
        if (ferror(rp)) perror("read error");
        fclose(rp);
    }
    return 0;
}
```

**Output:**

```
ROLL=101 NAME=Neel MARKS=85.50
ROLL=102 NAME=Mahir MARKS=90.00
ROLL=103 NAME=Yashvi MARKS=78.00
```

---

## 10) Quick gotchas & best practices

* **Always check** `fopen` for `NULL`, and check read/write results.
* Use **`perror`** (or `strerror(errno)`) to know **why** it failed.
* Prefer **`fgets`** when input may contain **spaces**.
* Don’t use `while (!feof(fp))` to read—**check the function’s return value**.
* Close files with `fclose` (and check the return) to flush buffers.
* On Windows, text files may use `\r\n`; functions like `fgets` handle this—strip `\r`/`\n` with `strcspn`.
* Keep formats stable; a small change in columns can break `fscanf`-based readers. For robust formats, consider CSV (with a proper parser) or JSON (later).

---