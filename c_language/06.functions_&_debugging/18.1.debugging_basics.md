# 18: Debugging Basics in C

---

## 1) What is Debugging?

**Debugging** is the process of finding and fixing errors (bugs) in your program.

In C, bugs often show up as:

* Wrong outputs (logic errors)
* Crashes (runtime errors like segmentation faults)
* Freezes (infinite loops)

Debugging is not about guessing, but about **observing what the program is really doing.**

---

## 2) Print-Based Debugging (printf method)

The easiest way to debug in C is to insert **`printf` statements** to trace variable values and program flow.

### Example: Buggy Sum Program

```c
#include <stdio.h>
int main() {
    int n = 5, sum;
    for (int i = 1; i <= n; i++) {
        sum = sum + i;   // ‚ùå Bug: sum not initialized
    }
    printf("Sum = %d\n", sum);
    return 0;
}
```

**Output (unpredictable)**

```
Sum = 32767   // garbage value
```

### Debugging with `printf`

```c
#include <stdio.h>
int main() {
    int n = 5, sum = 0;   // ‚úÖ initialize sum
    for (int i = 1; i <= n; i++) {
        printf("Before: i=%d sum=%d\n", i, sum); // debug
        sum = sum + i;
        printf("After:  i=%d sum=%d\n", i, sum); // debug
    }
    printf("Final Sum = %d\n", sum);
    return 0;
}
```

**Output trace**

```
Before: i=1 sum=0
After:  i=1 sum=1
Before: i=2 sum=1
After:  i=2 sum=3
...
Final Sum = 15
```

üëâ By printing, you **see where values go wrong**.

---

## 3) Common Runtime Errors

Great ‚Äî let‚Äôs expand **Section 3: Common Runtime Errors** into a **wrong vs fixed** style with **full code, input/output, and comments**. This way students won‚Äôt just read about errors ‚Äî they‚Äôll **see them happen** and know how to fix them.

---

## 3.1 Segmentation Fault (Invalid Memory Access)

Happens when you access memory that **doesn‚Äôt belong to you**.

### Wrong Code (Out of Bounds)

```c
#include <stdio.h>
int main() {
    int arr[5] = {10, 20, 30, 40, 50};

    // ‚ùå Accessing arr[5] when valid indices are 0..4
    printf("arr[5] = %d\n", arr[5]);

    return 0;
}
```

**Output**

```
Segmentation fault (core dumped)   // or garbage value
```

### Fixed Code

```c
#include <stdio.h>
int main() {
    int arr[5] = {10, 20, 30, 40, 50};

    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);  // ‚úÖ access within bounds
    }

    return 0;
}
```

**Output**

```
arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50
```

---

## 3.2 Infinite Loops

Caused by a **wrong or missing loop update/condition**.

### Wrong Code (Forgot update)

```c
#include <stdio.h>
int main() {
    int i = 1;
    while (i <= 5) {
        printf("%d ", i);
        // ‚ùå i++ missing ‚Üí loop never ends
    }
    return 0;
}
```

**Output**

```
1 1 1 1 1 1 1 ... (forever)
```

### Fixed Code

```c
#include <stdio.h>
int main() {
    int i = 1;
    while (i <= 5) {
        printf("%d ", i);
        i++;   // ‚úÖ update added
    }
    return 0;
}
```

**Output**

```
1 2 3 4 5
```

---

## 3.3 Uninitialized Variables

If you don‚Äôt **initialize** variables, they contain **garbage values**.

### Wrong Code

```c
#include <stdio.h>
int main() {
    int x;               // ‚ùå not initialized
    printf("x = %d\n", x);
    return 0;
}
```

**Output**

```
x = 32767   // garbage (random)
```

### Fixed Code

```c
#include <stdio.h>
int main() {
    int x = 0;           // ‚úÖ initialize before use
    printf("x = %d\n", x);
    return 0;
}
```

**Output**

```
x = 0
```

---

## 3.4 Division by Zero

C cannot divide by **zero** ‚Üí runtime crash.

### Wrong Code

```c
#include <stdio.h>
int main() {
    int a = 10, b = 0;

    printf("%d\n", a / b);   // ‚ùå divide by zero
    return 0;
}
```

**Output**

```
Floating point exception (core dumped)
```

### Fixed Code

```c
#include <stdio.h>
int main() {
    int a = 10, b = 0;

    if (b != 0) {
        printf("%d\n", a / b);   // ‚úÖ safe division
    } else {
        printf("Error: Division by zero not allowed!\n");
    }

    return 0;
}
```

**Output**

```
Error: Division by zero not allowed!
```

---

## 3.5 Using Freed or Dangling Pointers (advanced but common)

If you free memory and still use the pointer, you get undefined behavior.

### Wrong Code

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    int *p = malloc(sizeof(int));
    *p = 42;
    free(p);                // memory freed

    printf("%d\n", *p);     // ‚ùå using freed pointer ‚Üí undefined
    return 0;
}
```

**Output**

```
Segmentation fault (or random value)
```

### Fixed Code

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    int *p = malloc(sizeof(int));
    *p = 42;
    printf("%d\n", *p);   // ‚úÖ use before free
    free(p);
    p = NULL;             // ‚úÖ avoid dangling pointer
    return 0;
}
```

**Output**

```
42
```

---

# üîë Key Takeaways from Section 3

1. **Segfault** ‚Üí happens when you cross array limits or misuse pointers.
2. **Infinite loop** ‚Üí check your loop **condition** and **update**.
3. **Uninitialized variable** ‚Üí always assign before using.
4. **Division by zero** ‚Üí check denominator before dividing.
5. **Dangling pointer** ‚Üí set freed pointers to `NULL`.


---

## 4) Intro to gdb (GNU Debugger) \[Optional Advanced]

For larger programs, `printf` debugging is tedious.
C provides **gdb** (GNU debugger), which allows step-by-step execution.

### Steps

1. Compile with debugging info:

```
gcc -g prog.c -o prog
```

2. Run under gdb:

```
gdb ./prog
```

3. Common commands inside gdb:

* `run` ‚Üí run program
* `break main` ‚Üí set breakpoint at main
* `next` ‚Üí execute next line
* `print var` ‚Üí see variable value
* `backtrace` ‚Üí see call stack after crash
* `quit` ‚Üí exit gdb

---

### Example Debug Session

Buggy factorial:

```c
int fact(int n) {
    if (n == 0) return 0; // ‚ùå bug: should be return 1
    return n * fact(n-1);
}
```

Compile:

```
gcc -g fact.c -o fact
gdb ./fact
```

Inside gdb:

```
(gdb) break fact
(gdb) run
(gdb) print n
(gdb) backtrace
```

You‚Äôll see the wrong base case (returning 0 instead of 1).

---

## 5) Key Debugging Tips

* Use **`printf` generously** in small programs.
* **Initialize all variables**.
* **Check array bounds**.
* **Think about base cases** in recursion.
* Use `gdb` for step-by-step tracing in bigger programs.
* Debugging is like detective work: **don‚Äôt guess, observe**.

---

## 6) Quick Practice (Debug These)

1. What happens here?

```c
int arr[3] = {1,2,3};
printf("%d\n", arr[5]);
```

2. Fix this:

```c
int n=5, sum;
for(int i=1; i<=n; i++) sum += i;
```

3. Why does this loop never stop?

```c
int i=0;
while(i!=10) {
    i += 2;
}
```

---

## 7) Takeaway

* Debugging is **not magic**: it‚Äôs **systematic observation**.
* Start with **print-based debugging**.
* Understand **common runtime errors** (segfault, infinite loop, uninitialized values).
* For bigger projects, learn tools like **gdb**.

---
