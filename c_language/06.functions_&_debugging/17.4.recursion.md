# 17.4: Recursion in C

---

## 1) What is Recursion?

**Recursion** is when a function **calls itself** either **directly** or **indirectly**, until a certain condition (called the **base case**) is met.

Think of recursion like **Russian dolls**:

* Each doll contains a smaller doll.
* At some point, you reach the smallest doll (base case).
* Then, you put them back together (unwinding phase).

---

## 2) General Structure of Recursion

```c
return_type function(parameters) {
    if (base_condition) {
        // base case → stop recursion
        return some_value;
    } else {
        // recursive step → call function again
        return function(smaller_problem);
    }
}
```

**Key elements:**

1. **Base case** → stopping point (otherwise infinite recursion).
2. **Recursive step** → function calls itself on a smaller problem.
3. **Progress towards base case** → ensures termination.

---

## 3) First Example: Factorial

**Mathematics definition:**

```
n! = n × (n-1) × (n-2) × ... × 1
     = n × (n-1)!
     with 0! = 1 (base case)
```

**Code**

```c
#include <stdio.h>

int factorial(int n) {
    if (n == 0) return 1;   // base case
    return n * factorial(n - 1); // recursive case
}

int main() {
    int n = 5;
    printf("Factorial of %d = %d\n", n, factorial(n));
    return 0;
}
```

**Execution trace for `factorial(5)`**

```
factorial(5) → 5 * factorial(4)
factorial(4) → 4 * factorial(3)
factorial(3) → 3 * factorial(2)
factorial(2) → 2 * factorial(1)
factorial(1) → 1 * factorial(0)
factorial(0) → 1   <-- base case
```

Now, stack unwinds:

```
factorial(1) = 1 * 1 = 1
factorial(2) = 2 * 1 = 2
factorial(3) = 3 * 2 = 6
factorial(4) = 4 * 6 = 24
factorial(5) = 5 * 24 = 120
```

**Output**

```
Factorial of 5 = 120
```

---

## 4) Visualizing Recursion with the Stack

When recursion happens, C uses the **call stack**. Each function call creates a **new frame**.

For `factorial(3)`:

```
Call Stack (top → bottom)
-------------------------
factorial(0) → returns 1
factorial(1) → waits for factorial(0)
factorial(2) → waits for factorial(1)
factorial(3) → waits for factorial(2)
main
```

As base case returns, frames are removed (stack unwinding).

---

## 5) Example 2: Fibonacci Sequence

**Definition**

```
F(0) = 0, F(1) = 1
F(n) = F(n-1) + F(n-2)
```

**Code**

```c
#include <stdio.h>

int fib(int n) {
    if (n == 0) return 0; // base case 1
    if (n == 1) return 1; // base case 2
    return fib(n-1) + fib(n-2); // recursive step
}

int main() {
    int n = 6;
    printf("Fibonacci(%d) = %d\n", n, fib(n));
    return 0;
}
```

**Trace for `fib(4)`**

```
fib(4) = fib(3) + fib(2)
fib(3) = fib(2) + fib(1)
fib(2) = fib(1) + fib(0)
```

Tree expansion:

```
            fib(4)
           /      \
      fib(3)      fib(2)
      /   \       /   \
  fib(2) fib(1) fib(1) fib(0)
```

**Output**

```
Fibonacci(6) = 8
```

---

## 6) Example 3: Printing Numbers

### Print 1 to N

```c
void printAscending(int n) {
    if (n == 0) return;      // base case
    printAscending(n - 1);   // recursive call
    printf("%d ", n);        // executes while stack unwinds
}
```

**Trace for n=3**

```
printAscending(3)
 └─ printAscending(2)
     └─ printAscending(1)
         └─ printAscending(0) → return
         print 1
     print 2
 print 3
```

**Output**

```
1 2 3
```

---

### Print N to 1 (descending)

```c
void printDescending(int n) {
    if (n == 0) return;
    printf("%d ", n);
    printDescending(n - 1);
}
```

**Output for n=3**

```
3 2 1
```

---

## 7) Real-World Applications of Recursion

1. **File explorer traversal** (folders contain subfolders).
2. **Solving puzzles** (Towers of Hanoi, Sudoku).
3. **Mathematical problems** (factorial, Fibonacci, gcd).
4. **Algorithms**:

   * Binary search
   * Merge sort, Quick sort
   * Depth-first search (DFS)

---

## 8) Common Pitfalls in Recursion

1. **No base case** → infinite recursion, stack overflow.

```c
void bad() {
    printf("Hello\n");
    bad(); // ❌ no base case
}
```

2. **Wrong base case** → incorrect results.

```c
int fact(int n) {
    if (n == 1) return 0;  // ❌ wrong (should return 1)
    return n * fact(n-1);
}
```

3. **Too many recursive calls** → performance issues (e.g., naive Fibonacci is exponential).

4. **Forgetting return** in recursive function.

---

## 9) Recursion vs Iteration

| Feature     | Recursion                                     | Iteration                           |
| ----------- | --------------------------------------------- | ----------------------------------- |
| Basis       | Function calls itself                         | Loops (for, while)                  |
| Memory      | Uses stack frames                             | Constant memory                     |
| Readability | Often simpler to write for tree-like problems | Efficient for simple repetition     |
| Speed       | May be slower (overhead of calls)             | Generally faster                    |
| Use Cases   | Trees, backtracking, divide & conquer         | Counting, summing, repetitive tasks |

---

## 10) Practice Problems

1. Write a recursive function to **sum digits of a number** (e.g., `123 → 6`).
2. Write a recursive function to **reverse a string**.
3. Use recursion to **check if a number is prime**.

---

## 11) Key Takeaways

* **Every recursion must have:**

  * A **base case** (stop condition).
  * A **recursive step** (progress towards base case).
* Recursion uses the **stack**: function calls are pushed, then popped on return.
* Prefer recursion for **divide-and-conquer** or **tree-like problems**.
* Use iteration for **simple repetition**.

---

