# 17.3: Parameters vs Arguments

*(Call by Value & Call by Reference in C)*

---

## 1) Parameters vs Arguments

When writing a function in C, you must understand two different but related terms:

* **Parameters** ‚Üí variables declared inside the function definition.
* **Arguments** ‚Üí actual values or variables you supply when calling the function.

Think of it like a **ticket system**:

* The **ticket format** is fixed (parameters).
* The **actual ticket filled with details** is the argument.

Example:

```c
#include <stdio.h>

// parameter: int x
void square(int x) {
    printf("Square = %d\n", x * x);
}

int main() {
    int num = 5;   // argument
    square(num);   // call with argument
    return 0;
}
```

* `int x` ‚Üí **parameter** (placeholder).
* `num` (value = 5) ‚Üí **argument**.

**Output**

```
Square = 25
```

---

## 2) Call by Value (Default in C)

In **Call by Value**, a **copy** of the argument is given to the function.
The function works only with this copy.
The **original variable remains unchanged**.

### Analogy

Imagine photocopying your homework and giving it to a friend.
Your friend can scribble on the photocopy (parameter), but your original (argument) is safe.

### Example

```c
#include <stdio.h>

void modify(int x) {
    // x is a COPY of num
    x = x + 5;
    printf("Inside function: x=%d\n", x);
}

int main() {
    int num = 10;
    modify(num);  // num passed by value (copy created)
    printf("Outside function: num=%d\n", num);
    return 0;
}
```

**Trace**

* Function gets a new variable `x` with value `10`.
* `x` is modified to `15`.
* But `num` in `main` is still `10`.

**Output**

```
Inside function: x=15
Outside function: num=10
```

üëâ **Conclusion**: Changes inside the function don‚Äôt affect the caller.

---

## 3) Call by Reference (using pointers in C)

C does not have built-in ‚Äúcall by reference‚Äù like C++ does.
But we can **simulate it using pointers**: instead of passing the value, we pass the **address** of the variable.
The function uses this address to access and change the original variable.

### Analogy

Instead of a photocopy, you give your friend the **original notebook**.
Any changes your friend makes will affect your notebook.

### Example

```c
#include <stdio.h>

void modify(int *x) {
    // *x means "the value at the address of num"
    *x = *x + 5;  // changes the actual num
    printf("Inside function: *x=%d\n", *x);
}

int main() {
    int num = 10;
    modify(&num);   // pass the ADDRESS of num
    printf("Outside function: num=%d\n", num);
    return 0;
}
```

**Trace**

* Function receives the **address of num**.
* `*x` points directly to `num`.
* When function modifies `*x`, it modifies `num` itself.

**Output**

```
Inside function: *x=15
Outside function: num=15
```

üëâ **Conclusion**: Changes inside the function DO affect the caller.

---

## 4) Side-by-Side Comparison

```c
#include <stdio.h>

// Call by value
void byValue(int x) {
    x = x + 1;
    printf("Inside byValue: x=%d\n", x);
}

// Call by reference
void byReference(int *x) {
    *x = *x + 1;
    printf("Inside byReference: *x=%d\n", *x);
}

int main() {
    int num = 5;

    byValue(num);       // pass copy
    printf("After byValue: num=%d\n", num);

    byReference(&num);  // pass address
    printf("After byReference: num=%d\n", num);

    return 0;
}
```

**Output**

```
Inside byValue: x=6
After byValue: num=5

Inside byReference: *x=6
After byReference: num=6
```

---

## 5) Key Differences Explained

| Feature            | Call by Value             | Call by Reference                 |
| ------------------ | ------------------------- | --------------------------------- |
| What is passed     | A copy of the value       | The address of the variable       |
| Function works on  | A temporary copy          | The actual variable               |
| Effect on original | No change                 | Changed if modified               |
| Safety             | Safe (original untouched) | Risky (original may be corrupted) |
| Default in C?      | Yes                       | No (must use pointers)            |

---

## 6) Visualizing with Memory

Say `num = 10`.

* In **call by value**, C copies `10` into another box.
* In **call by reference**, C gives the function the **key to the original box**.

---

## 7) Quick Practice

### A) Swap Numbers (fail with call by value)

```c
void swapValue(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("Inside swapValue: a=%d, b=%d\n", a, b);
}
```

If `main` calls `swapValue(x,y)`, nothing changes in `main`.

---

### B) Swap Numbers (success with call by reference)

```c
void swapRef(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
    printf("Inside swapRef: *a=%d, *b=%d\n", *a, *b);
}
```

This works because we pass addresses.

---

## 8) Takeaways

* In **C**, all arguments are technically **passed by value**.
* But if the argument is a **pointer or array**, the function can indirectly modify the original data.
* Use **call by value** when you want safety.
* Use **call by reference** when you want the function to modify caller‚Äôs variables (e.g., swap, updating arrays, returning multiple results).

---
