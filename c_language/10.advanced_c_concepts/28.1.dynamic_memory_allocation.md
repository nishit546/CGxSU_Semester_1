# 28: Dynamic Memory Allocation in C

In most programs, the size of arrays is **fixed at compile time**. But what if you don’t know how many students, numbers, or strings you’ll need until **runtime**? That’s where **Dynamic Memory Allocation (DMA)** comes in.

DMA lets you **request memory from the heap while the program is running** using special functions from `<stdlib.h>`. Unlike local variables (stack), heap memory persists until you `free()` it.

We’ll cover:

* `malloc`
* `calloc`
* `realloc`
* `free`
* Example: **Dynamic storage for student names**

---

## 1) `malloc` – Memory Allocation

```c
ptr = (type*) malloc(size_in_bytes);
```

* Allocates a block of **uninitialized memory** (contents are garbage).
* Returns a **pointer** to the first byte.
* Returns `NULL` if allocation fails.

### Example: Allocate array of 5 integers

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int*) malloc(5 * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;  // assign values
    }

    printf("Array: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }

    free(arr);  // release memory
    return 0;
}
```

**Output**

```
Array: 1 2 3 4 5
```

---

## 2) `calloc` – Contiguous Allocation

```c
ptr = (type*) calloc(num_elements, element_size);
```

* Allocates **multiple elements**, initializes them to `0`.
* Safer than `malloc` if you want a **clean slate**.

### Example: Allocate 5 integers (initialized to 0)

```c
int *arr = (int*) calloc(5, sizeof(int));
for (int i = 0; i < 5; i++) {
    printf("%d ", arr[i]);  // prints 0 0 0 0 0
}
free(arr);
```

---

## 3) `realloc` – Resize Memory

```c
ptr = (type*) realloc(old_ptr, new_size);
```

* Changes the size of an allocated block.
* Keeps existing data (up to new size).
* May **move block** to a new location if needed.

### Example: Expand array from 5 → 10 integers

```c
int *arr = (int*) malloc(5 * sizeof(int));
for (int i = 0; i < 5; i++) arr[i] = i + 1;

arr = (int*) realloc(arr, 10 * sizeof(int));
for (int i = 5; i < 10; i++) arr[i] = (i+1)*10;

printf("Resized array: ");
for (int i = 0; i < 10; i++) printf("%d ", arr[i]);

free(arr);
```

**Output**

```
Resized array: 1 2 3 4 5 60 70 80 90 100
```

---

## 4) `free` – Release Memory

Always `free()` after use, otherwise memory leaks occur.

```c
free(pointer);
pointer = NULL; // best practice (avoid dangling pointer)
```

---

## 5) Full Example – Dynamic Storage for Student Names

Imagine you don’t know the number of students in advance. You want to store names dynamically.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int n;
    printf("Enter number of students: ");
    scanf("%d", &n);

    char **names = (char**) malloc(n * sizeof(char*));
    if (names == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        char temp[100];
        printf("Enter name of student %d: ", i+1);
        scanf("%s", temp);

        // allocate exact memory for this name (+1 for '\0')
        names[i] = (char*) malloc(strlen(temp) + 1);
        strcpy(names[i], temp);
    }

    printf("\nStudent List:\n");
    for (int i = 0; i < n; i++) {
        printf("Student %d: %s\n", i+1, names[i]);
        free(names[i]);  // free each string
    }

    free(names); // free the array of pointers
    return 0;
}
```

### Sample Run

```
Enter number of students: 3
Enter name of student 1: Jenil
Enter name of student 2: Arjun
Enter name of student 3: Priyesha

Student List:
Student 1: Jenil
Student 2: Arjun
Student 3: Priyesha
```

---

## 6) Quick Recap

* **`malloc(n*size)`** → uninitialized memory.
* **`calloc(n,size)`** → initialized to `0`.
* **`realloc(ptr,new_size)`** → grow/shrink while preserving data.
* **`free(ptr)`** → always release memory when done.
* Useful for **dynamic arrays, strings, databases**.

---
