# 29: Advanced Pointers in C

So far, we‚Äôve worked with **basic pointers**: storing the address of a variable and dereferencing it.
Now it‚Äôs time to unlock their **real power** with:

1. **Pointer Arithmetic**
2. **Pointers to Pointers (`**`)**
3. **Function Pointers**

Each of these concepts is central to writing **flexible, memory-efficient programs** in C.

---

## 1) Pointer Arithmetic

A pointer doesn‚Äôt just store a memory address ‚Äî it also **knows the type** it points to.
That‚Äôs why pointer arithmetic doesn‚Äôt simply move by 1 byte; it moves by the **size of the type**.

### Example 1: Traversing an array with pointers

```c
#include <stdio.h>
int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *p = arr; // points to first element (arr[0])

    for (int i = 0; i < 5; i++) {
        // Iteration trace:
        // i=0: p=&arr[0] ‚Üí *p=10
        // i=1: p=&arr[1] ‚Üí *p=20
        // i=2: p=&arr[2] ‚Üí *p=30
        // i=3: p=&arr[3] ‚Üí *p=40
        // i=4: p=&arr[4] ‚Üí *p=50
        printf("Address=%p, Value=%d\n", (void*)p, *p);
        p++; // move to next int (4 bytes ahead, usually)
    }
    return 0;
}
```

**Sample Output**

```
Address=0x7ffeed3b5a80, Value=10
Address=0x7ffeed3b5a84, Value=20
Address=0x7ffeed3b5a88, Value=30
Address=0x7ffeed3b5a8c, Value=40
Address=0x7ffeed3b5a90, Value=50
```

üëâ Notice: addresses increase by **4 bytes** each time (because `int` is 4 bytes here).

---

### Example 2: Subtracting pointers

```c
#include <stdio.h>
int main() {
    int arr[] = {100, 200, 300};
    int *p1 = &arr[0];
    int *p2 = &arr[2];

    printf("p2 - p1 = %ld\n", p2 - p1); // number of elements apart
    return 0;
}
```

**Output**

```
p2 - p1 = 2
```

üëâ Subtracting two pointers gives **element distance**, not raw byte difference.

---

### Example 3: Out-of-bounds danger üö®

```c
#include <stdio.h>
int main() {
    int arr[3] = {1, 2, 3};
    int *p = arr;

    printf("%d\n", *(p + 5)); // ‚ùå UB: accessing out of array
    return 0;
}
```

This may print garbage or crash.
**Rule**: Pointer arithmetic is valid **only inside the same array**.

---

## 2) Pointers to Pointers (`**`)

Sometimes we don‚Äôt just need the address of a variable ‚Äî we need the **address of a pointer**.
That‚Äôs where **pointer to pointer** comes in.

### Example 1: Basic pointer-to-pointer

```c
#include <stdio.h>
int main() {
    int x = 42;

    int *p = &x;   // pointer to int
    int **pp = &p; // pointer to pointer to int

    printf("x=%d\n", x);
    printf("*p=%d\n", *p);     // dereference once
    printf("**pp=%d\n", **pp); // dereference twice
    return 0;
}
```

**Output**

```
x=42
*p=42
**pp=42
```

---

### Example 2: Function modifying pointer (call by reference)

```c
#include <stdio.h>
#include <stdlib.h>

// function that allocates memory and modifies pointer
void allocateArray(int **ptr, int n) {
    *ptr = (int*)malloc(n * sizeof(int)); // modifies caller's pointer
    for (int i = 0; i < n; i++) {
        (*ptr)[i] = i * 10; // fill array
    }
}

int main() {
    int *arr = NULL;
    allocateArray(&arr, 5); // pass address of pointer

    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    free(arr); // release memory
    return 0;
}
```

**Output**

```
0 10 20 30 40
```

üëâ Here, `allocateArray` changes the **caller‚Äôs pointer** by using a **pointer to pointer**.

---

## 3) Function Pointers

Functions in C are stored in memory like everything else.
We can store their addresses in **function pointers**, and call them indirectly.

---

### Example 1: Simple function pointer

```c
#include <stdio.h>
int add(int a, int b) {
    return a + b;
}
int main() {
    int (*fp)(int, int); // declare pointer to function
    fp = add;            // assign address of function

    int result = fp(5, 3); // call function through pointer
    printf("Result = %d\n", result);
    return 0;
}
```

**Output**

```
Result = 8
```

---

### Example 2: Array of function pointers (choose operation)

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

int main() {
    // array of function pointers
    int (*ops[3])(int, int) = {add, sub, mul};

    int a = 6, b = 3;
    printf("Add = %d\n", ops[0](a, b));
    printf("Sub = %d\n", ops[1](a, b));
    printf("Mul = %d\n", ops[2](a, b));
    return 0;
}
```

**Output**

```
Add = 9
Sub = 3
Mul = 18
```

üëâ This is the foundation of **callbacks** and **plug-in architectures**.

---

### Example 3: Using function pointer with `qsort`

`qsort` from `<stdlib.h>` needs a **custom comparison function** ‚Äî a perfect real-life case of function pointers.

```c
#include <stdio.h>
#include <stdlib.h>

// comparison function for integers
int cmp(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int arr[] = {42, 7, 19, 73, 5};
    int n = sizeof(arr)/sizeof(arr[0]);

    qsort(arr, n, sizeof(int), cmp); // pass cmp as function pointer

    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```

**Output**

```
5 7 19 42 73
```

---

## 4) Key Takeaways

1. **Pointer arithmetic**

   * `p++` moves to the next element, not byte.
   * Works only inside array bounds.

2. **Pointers to pointers (`**`)**

   * Let you modify pointers inside functions.
   * Essential for dynamic memory and 2D arrays.

3. **Function pointers**

   * Store addresses of functions.
   * Enable callbacks, custom logic (`qsort`), runtime function selection.

---

