# Error handling in JavaScript 

> “When something goes wrong, don’t let the whole program crash.
> Catch the problem, handle it nicely, and (optionally) clean up after.”

There are **four main keywords** you should know:

* `try`
* `catch`
* `finally`
* `throw`

---

## 1. `try` – “Try to run this risky code”

You put code **inside `try`** when you think:

* “This part *might* fail”
* “If it fails, I don’t want the whole script to stop”

Example idea (not focusing on code details):
Inside `try`, you might:

* Call an API
* Parse JSON
* Read a property from an object that may be `undefined`

If something goes wrong **inside `try`**, JavaScript will:

* Immediately jump to the `catch` block.
* Skip the rest of the code inside `try`.

---

## 2. `catch` – “If an error happens, handle it here”

The `catch` block runs **only if** something inside `try` throws an error.

In `catch`, you usually:

* Show a friendly message to the user
* Log the error for debugging
* Maybe use some default values

Conceptually:

```js
try {
  // risky code
} catch (error) {
  // handle problem here
}
```

You can think of it as:

* `try`: “Do this.”
* `catch`: “If it breaks, do this instead.”

---

## 3. `finally` – “Always run this, success or failure”

`finally` is an optional block after `try` / `catch`.

It runs:

* Whether there was an error or not.
* Whether `catch` ran or not.

Use `finally` for **cleanup work**:

* Closing a modal/spinner/loading indicator
* Clearing a timer
* Releasing a resource

Conceptually:

```js
try {
  // risky code
} catch (error) {
  // handle error
} finally {
  // always runs
}
```

Think:

* `try`: “Do the work.”
* `catch`: “Handle any problem.”
* `finally`: “Clean up no matter what.”

---

## 4. `throw` – “Create your own error”

`throw` lets **you** manually create an error.

Why would you do that?

* When **logically** something is wrong, even if JavaScript itself didn’t crash yet.
* Example situations:

  * A required value is missing.
  * API response has the wrong format.
  * User input is invalid in a way you care about.

Conceptually:

```js
if (somethingIsWrong) {
  throw new Error("Something is wrong");
}
```

When you `throw`:

* Execution jumps out of the current block.
* If there is a surrounding `try...catch`, it will go into `catch`.

So you often see:

```js
try {
  if (!dataIsValid) {
    throw new Error("Invalid data");
  }
  // normal code
} catch (error) {
  // handle "Invalid data"
}
```

---

## Putting it all together in words

1. Wrap dangerous code in **`try`**.
2. If something fails or you **`throw`** an error yourself:

   * Control jumps to **`catch`**, where you handle it.
3. After that, **`finally`** runs (if present), no matter what happened:

   * Success, failure, return, throw — `finally` still runs.

## Code

```javascript
function divide(a, b) {
  console.log("divide() started");

  try {
    // 1) Check for invalid input
    if (b === 0) {
      // create our own error
      throw new Error("Cannot divide by zero");
    }

    // 2) If no error, do the division
    const result = a / b;
    console.log("Result is:", result);
  } catch (error) {
    // 3) This runs if anything in try throws an error
    console.log("Something went wrong:", error.message);
  } finally {
    // 4) This always runs (success OR error)
    console.log("divide() finished");
  }
}

// Test calls
divide(10, 2); // valid
divide(10, 0); // will throw and be caught
```

---

## Explanation in plain words

* `try { ... }`

  * Put the **risky code** here.
  * In this example, dividing by `b`, but before that we **check** if `b === 0`.

* `throw new Error("Cannot divide by zero");`

  * We are **manually creating an error**.
  * As soon as `throw` runs:

    * JavaScript stops running the rest of the `try` block.
    * It jumps directly to the `catch` block.

* `catch (error) { ... }`

  * This block runs **only if** there was an error in `try`.
  * Here we show a friendly message: `"Something went wrong: Cannot divide by zero"`.

* `finally { ... }`

  * This block runs **every time**, whether there was an error or not.
  * Good place for “cleanup” or logging like `"divide() finished"`.

So for:

* `divide(10, 2)`

  * `b` is not 0 → no throw → `catch` is skipped → `finally` still runs.
* `divide(10, 0)`

  * `b === 0` → we `throw` → jump to `catch` → then `finally` runs.
